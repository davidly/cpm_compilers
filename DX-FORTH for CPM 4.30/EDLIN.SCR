\ EDLIN - Information                                                                                                           A simple line-oriented screen editor.                                                                                           It uses the same commands as the editor in 'Starting Forth' and is a slightly modified version of the editor that appeared in   Forth Dimensions III/3.                                                                                                         Note: Editing of screens with a line editor is rather tedious   and is best avoided (see EDITOR.SCR for a full-screen editor).  However it does have the advantage that it does not need to be  installed and works with any video terminal.                                                                                                                                                                                                                                                                                    \ Load screen                                                   forth definitions  decimal  application                                                                                         cr .( loading Line Editor )      2 #screens 1- thru                                                                             application                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \ EDITOR r# c/l delim                                           system                                                          vocabulary EDITOR                                               editor definitions                                                                                                              variable r#             \ cursor position                       char ^ constant delim   \ delimiter used by editor                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              \ text match                                                    \ get string from input stream and save to pad                  : text ( char -- )                                                word pad dup c/l 1+ blank over c@ 1+ cmove ;                                                                                  \ string search                                                 : match ( adr len sadr slen -- flag cursor-offs )                 dup >r  2 pick >r                                               search  rot drop                                                tuck if                                                           2r> rot - +                                                   else  2r> 2drop then ;                                                                                                                                                                                                                                                                                                        \ line #locate #lead #lag                                       \ start address of line                                         : line ( ln -- adr )  scr @ block swap c/l * + ;                                                                                \ cursor offset and line                                        : #locate ( -- offs ln )  r# @  c/l /mod ;                                                                                      \ line address and offset to cursor                             : #lead ( -- adr offs )  #locate line swap ;                                                                                    \ cursor address and count after cursor                         : #lag ( -- adr count )  #lead dup >r + c/l r> - ;                                                                                                                                                                                                                                                                              \ -move buf-move >line# find-buf                                \ move line from adr to new line                                : -move ( adr ln -- )  line c/l cmove update ;                                                                                  \ move pad text to buffer adr                                   : buf-move ( adr -- )                                             pad c@ if ( not empty )                                           pad swap c/l 1+ cmove                                         else drop then ;                                                                                                              \ compute line from cursor position                             : >line# ( -- ln )  #locate nip ;                                                                                               \ find buffer address                                           : find-buf ( -- adr )  pad 80 + ;                                                                                               \ insert-buf (hold) (kill) (spread)                             \ insert buffer address                                         : insert-buf ( -- adr )  pad 160 + ;                                                                                            \ copy current line to insert buffer                            : (hold) ( ln -- )                                                line insert-buf 1+ c/l dup insert-buf c! cmove ;                                                                              \ blank specified line                                          : (kill) ( ln -- )  line c/l blank update ;                                                                                     \ spread screen starting at current line, last line is lost     : (spread) ( -- )                                                 >line# dup 1- c/l 2- do i line i 1+ -move -1 +loop (kill) ;                                                                                                                                   \ (top) (r) seek-error 1line                                    \ reset cursor position to top of screen                        : (top) ( -- )  0 r# ! ;                                                                                                        \ replace current line with contents of search buffer           : (r) ( -- )  >line# insert-buf 1+ swap -move ;                                                                                 \ reset cursor position, display error message                  : seek-error ( -- )                                               (top) find-buf count type ."  not found" abort ;                                                                              \ scan current line for match with contents of find buffer      : 1line ( -- flag )  #lag find-buf count match r# +! ;                                                                                                                                                                                                          \ (seek) (delete) (f)                                           \ search rest of screen                                         : (seek) ( -- )                                                   begin                                                             b/buf 1- r# @ < if seek-error then 1line                      until ;                                                                                                                       \ delete n characters backwards                                 : (delete) ( n -- )                                               >r #lag + r@ - #lag r@ negate r# +!                             #lead + swap cmove r> blank update ;                                                                                          \ copy text to find buffer and search line                      : (f) ( "text" -- )                                               delim text find-buf buf-move (seek) ;                                                                                         \ ? T X                                                         \ display line and cursor position                              -? : ? ( -- )                                                     cr space #lead type delim emit                                  #lag type #locate 2 .r space drop ;                                                                                           \ type                                                          : T ( ln# -- )  c/l * r# ! ? ;                                                                                                  \ extract                                                       : X ( -- )                                                        >line# dup (hold) c/l 1- dup rot do                               i 1+ c/l 1- min line i -move                                  loop (kill) ;                                                                                                                                                                                 \ P U F E                                                       \ put                                                           : P ( "text" -- )  delim text insert-buf buf-move (r) ;                                                                         \ under                                                         : U ( "text" -- )  c/l r# +! (spread) p ;                                                                                       \ find                                                          : F ( "text" -- )  (f) ? ;                                                                                                      \ erase                                                         : E ( -- )  find-buf c@ (delete) ? ;                                                                                                                                                                                                                                                                                            \ D TILL WIPE                                                   \ delete                                                        : D ( "text" -- )  (f) e ;                                                                                                      \ till                                                          : TILL ( "text" -- )                                              #lead +  delim text                                             find-buf buf-move                                               1line 0= if seek-error then                                     #lead + swap - (delete) ? ;                                                                                                   \ wipe                                                          : WIPE ( -- )  c/l 0 do i (kill) loop ;                                                                                                                                                                                                                         \ S                                                             \ search until block blk#-1                                     : S ( blk# "text" -- )                                            depth 0= if #screens then  #screens min  1 max                  delim text  find-buf buf-move                                   scr @  dup r# @ 2>r do            \ save current location         i scr ! (top)                                                   begin                                                             1line if ? scr @ 4 .r then                                      b/buf 1- r# @ <                                               until                                                           key? if key drop leave then     \ any key to stop             loop                                                            2r> r# ! scr ! ;                                                                                                                                                                              \ I R                                                           \ insert                                                        -? : I ( "text" -- )                                              delim text                                                      insert-buf buf-move                                             insert-buf count #lag rot over min >r                           r@ r# +! r@ - >r                                                dup here r@ cmove                                               here #lead + r> cmove                                           r> cmove update ? ;                                                                                                           \ replace                                                       : R ( -- )  e i ;                                                                                                                                                                                                                                               \ M                                                             \ move                                                          : M ( blk# line# -- )                                             scr @ >r r# @ >r                                                >line# (hold) swap scr !                                        1+ c/l * r# !                                                   (spread) (r)                                                    r> c/l + r# ! r> scr ! ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      \ (edit) EDIT                                                   \ Edit screen scr, placing cursor at offset                     : (edit) ( scr offs -- )                                          editor  swap cr list  dup r# !  c/l / cr t ;                                                                                  forth definitions editor                                        \ Edit screen u or where error occured                          : EDIT ( blk# | -- )                                              depth if  0  else  scr 2@ swap  then (edit) ;                                                                                 behead r# (f)                                                   behead (edit) (edit)                                                                                                            forth                                                                                                                                                                                           