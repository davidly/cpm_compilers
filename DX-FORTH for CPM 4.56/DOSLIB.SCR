\ Information                                                                                                                   NEWAPP is a skeletal program that allows users to quickly       develop a DOS application. It provides often needed tasks       including error handling, command-line parsing, file            operations, buffered I/O, help screen, number and string        functions.                                                                                                                      NEWAPP comprises two parts:                                                                                                       NEWAPP.SCR   skeletal application program                       DOSLIB.SCR   function support library                                                                                                                                                                                                                                                                                         \ Module loader                                                                                                                 cr ." DOSLIB  2024-05-10 " cr                                                                                                   base @  sys @  decimal  system                                                                                                  -? : module ( u siz "name" -- u2 )  over + tuck 1-                2constant does> 2@ [ loadfile -path ] sliteral loaded ;                                                                       2 load  behead module module                                                                                                    sys !  base !                                                                                                                                                                                                                                                                                                                   \ Directory                                                      5 2  module _Errors        \ error handler                        1  module _Inout1        \ number output                        1  module _Inout2        \                                      1  module _Compare1      \ basic compare                        2  module _String1       \ basic strings                        1  module _String2       \ extra strings                        5  module _Parse1        \ cmdline parsing                      1  module _Parse2        \ cmdline extra                       12  module _Files         \ default files                        1  module _Bread         \ buffer read char                     2  module _Bread2        \ buffer read data/text                1  module _Bwrite        \ buffer write char                    1  module _Bwrite2       \ buffer write data/text            -->                                                                                                                             \ Directory                                                        1  module _Random        \ random numbers                       1  module _Shuffle       \ shuffle cells                        1  module _Qsort         \ quicksort cells                      1  module _Dos1          \ fcb                                  2  module _Disk          \ disk                                 2  module _Timeconv      \ convert                              1  module _Timepack      \ packing                              1  module _Clock         \ clock                                2  module _Filematch     \ file find first/next                 1  module _Wildexp       \ file wildcard expander               1  module _Fileattr      \ file attribute                    -->                                                                                                                                                                                                                                                             \ Directory                                                     \   1  module _Env           \ environment                      \   3  module _Exec          \ exec prog/command                \   2  module _Video1        \ textcolor attrib cursor          \   1  module _Video2        \ mode page                        \   1  module _Timing1       \ timer                            \   1  module _Timing2       \ delay                            \   1  module _Timing3       \ timer0 mode                      \   2  module _Device1       \ 8087 cpu keybd                   drop                                                                                                                                                                                                                                                                                                                                                                                                                                                            \ Errors: +IS ?THROW ?CATCH                                     system                                                          \ Add new behaviour to existing deferred word                   : +IS ( xt <name> -- )  >r  :noname  r> compile,                  ' >body  dup >r  @ compile,  postpone ;  r> ! ;               application                                                                                                                     \ THROW exception code n if flag is non-zero                    : ?THROW ( flag n -- )  swap 0<> and throw ;                                                                                    \ Perform CATCH intercepting exception code n only              : ?CATCH ( xt n -- n )  >r catch dup r> <> over and throw ;                                                                                                                                                                                                                                                                     \ Errors: .ABORT STOPKEY= STOPKEY? ?STOPKEY                     \ Quit to DOS with abort msg and return code = 1                : .ABORT ( -- )  ."  ... aborting"  abort ;                                                                                     \ Test char for ESC or Ctrl-C                                   : STOPKEY= ( char -- flag )  dup #27 =  swap 3 =  or ;                                                                          \ Test key and return true if stopkey                           : STOPKEY? ( -- flag )  key? if  key stopkey=  end  0 ;                                                                         \ Test key and confirm abort if stopkey                         : ?STOPKEY ( -- )  stopkey? if  beep cr                             ." User break - exit program? "  y/n  if  .abort  then        then ;                                                                                                                                                                                        \ Inout1: UD. UD.R (H.) (HB.) H. HB.                            \ Unsigned double                                               : UD.   ( ud -- )  (ud.) type space ;                           : UD.R  ( ud +n -- )  >r (ud.) r> s.r ;                                                                                         \ Hex formatted                                                 : (H.)  ( u -- adr len )  [ 2 cells ] literal (h.n) ;           : (HB.) ( u -- adr len )  2 (h.n) ;                             : H.    ( u -- )  (h.) type space ;                             : HB.   ( u -- )  (hb.) type space ;                                                                                                                                                                                                                                                                                                                                                                                                                            \ Inout2:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       \ Compare1: DIGIT? ALPHA?                                       \ Return true if char is decimal digit                          : DIGIT? ( char -- flag )  [char] 0 - #10 u< ;                                                                                  \ Return true if char is alphabetical                           : ALPHA? ( char -- flag )  upcase [char] A - #26 u< ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \ String1: SPLIT /SPLIT S=                                      \ Split string at character leaving first on top                : SPLIT ( a u c -- a2 u2 a3 u3 )                                  >r 2dup r> scan 2swap 2 pick - ;                                                                                              \ Split string at index n leaving first on top                  : /SPLIT ( a u n -- a2 u2 a3 u3 )                                 >r over r@ 2swap r> /string 2swap ;                                                                                           \ Compare two strings for equality                              : S= ( a1 u1 a2 u2 -- flag )  compare 0= ;                                                                                                                                                                                                                                                                                                                                                      \ String1: RJUST (S.R)                                          \ Return string right-aligned as a2 u2. Uses HOLD buffer        : RJUST ( a u +n c -- a2 u2 )                                     >r  over - 0 max >r  <# shold  r> r> nhold  held ;                                                                            : (S.R) ( a u +n -- a2 u2 )  bl rjust ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         \ String2: +CHAR \CHAR \STRING                                  \ Append character to end of string:  2dup 2>r + c! 2r> 1+      code +CHAR ( c a u -- a2 u2 )  d pop  h pop  xthl  l a mov        h pop  h push  d dad  a m mov  d inx  d push  next  end-code                                                                  \ Extract character from end of string:  1- 2dup + c@           code \CHAR ( a u -- a2 u2 c )  d pop  h pop  d dcx  h push        d push  d dad  m l mov  0 h mvi  1push  end-code                                                                              \ Return u right-most characters                                : \STRING ( a1 u1 u -- a2 u2 )  >r + r@ - r> ;                                                                                                                                                                                                                                                                                                                                                  \ Parse1: .BAD ?BAD ?END ?D>S ?RNG /DNUM /NUM /HEX              \ Error handling                                                : .BAD ( -- )  cr ." Invalid item"  .abort ;                    : ?BAD ( f -- )  0= if .bad then ;                              : ?END ( u -- u )  dup if .bad then ;                                                                                           : ?D>S ( d|ud -- n|u )  -1 0 between ?bad ;                     : ?RNG ( n|u lo hi -- n|u )  2>r dup 2r> between ?bad ;                                                                         : /DNUM ( a u -- a' 0 d|ud )  \ parse double number               dup ?bad  /number  2swap ?end 2swap ;                                                                                         : /NUM ( a u -- a' 0 n|u )  /dnum ?d>s ;                                                                                        : /HEX ( a u -- a' 0 n|u )  base @ >r  hex /num  r> base ! ;                                                                    \ Parse1: ARGC /ARG !ARG ARGV                                   create ARGC ( -- a )  3 cells allot                                                                                             \ Reset command parser                                          : /ARG ( -- )  argc off ;                                                                                                       \ Assign string for parsing                                     : !ARG ( a u -- )  argc cell+ 2!  /arg ;  here 0 !arg                                                                           \ Get next blank delimited argument                             : ARGV ( -- a u -1 | 0 )                                          1 argc +!  argc cell+ 2@  0 0                                   argc @ 0 ?do  2drop  bl skip  bl split  loop 2nip               dup if -1 end  and ;                                                                                                                                                                          \ Parse1: SETOPT                                                \ Set switch                                                    defer SETOPT ( a u char -- a' u' )  ' drop is setopt                                                                            \\ Example of use                                               :noname ( a u char -- a' u' )                                     upcase [char] A = if  A-variable on  end                        .bad ;  is setopt                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             \ Parse1: PARSEFN                                               \ Parse filenames                                               defer PARSEFN ( -- )  ' noop is parsefn                                                                                         \\ Example of use                                               :noname ( -- )                                                    argv 0= if ." no filename specified"  .abort  then              infile !fname ;  is parsefn                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   \ Parse1: PARSEOPT PARSECMD                                     \ Parse switch options                                          : PARSEOPT ( -- )                                                 begin  argv while ( not end)                                      /char  $FD and  [char] -  \ switch '-' or '/'                   - if  2drop  -1 argc +! ( backup)  end                          begin  dup while  /char setopt  repeat 2drop                  repeat ;                                                                                                                      \ Parse the command string                                      : PARSECMD ( a u -- )                                             !arg  parseopt  parsefn  argv ?end drop ;                                                                                                                                                                                                                                                                                     \ Parse2: /INT (NUM) ?SKIP FIRSTNUM NEXTNUM                     : /INT ( a u -- a' u' n|u )  /number ?d>s ;                                                                                     defer (NUM)  ' /int is (num)                                                                                                    \ Skip next char if not empty; abort if no match                : ?SKIP ( a u char -- a' u' )                                     over if  >r /char r> = ?bad  end  drop ;                                                                                      \ Parse first number; false if string empty                     : FIRSTNUM ( a u -- a' u' num true | a 0 false )                  dup if  (num) -1  end  0 ;                                                                                                    \ Parse comma separated number; false if string empty           : NEXTNUM ( a u -- a' u' num true | a 0 false )                   dup if  [char] , ?skip  firstnum  end  0 ;                    \ Files: ?FERROR                                                \ Display msg and abort on file error                           : ?FERROR ( ior err# -- )                                         swap if                                                           cr ." File "  cond                                                3  of  ." read"  else                                           4  of  ." write"  else                                          5  of  ." position"  else                                       6  of  ." size"  else                                           .                                                             cont  ."  error"  .abort                                      then  drop ;                                                                                                                                                                                                                                                                                                                  \ Files: FREAD FWRITE FREADLN FWRITELN                          \ Read binary                                                   : FREAD ( a u fid -- a u2 )                                       ?stop  2>r dup 2r>  read-file  3 ?ferror ;                                                                                    \ Write binary                                                  : FWRITE ( a u fid -- )  ?stop  write-file  4 ?ferror ;                                                                         \ Read text  n: 0=EOF -1=EOL 1=EOL not recv'd                   : FREADLN ( a u fid -- a u2 n )                                   ?stop  2>r dup 2r>  read-line  3 ?ferror ;                                                                                    \ Write text                                                    : FWRITELN ( a u fid -- )  ?stop  write-line  4 ?ferror ;                                                                                                                                       \ Files: FPOS FSEEK FSIZE FRESIZE                               \ Get file position                                             : FPOS ( fid  -- ud )  file-position  5 ?ferror ;                                                                               \ Reposition file                                               : FSEEK ( ud fid  -- )  reposition-file  5 ?ferror ;                                                                            \ Get file size                                                 : FSIZE ( fid  -- ud )  file-size  6 ?ferror ;                                                                                  \ Resize file                                                   \ : FRESIZE ( ud fid  -- )  resize-file  6 ?ferror ;                                                                                                                                                                                                                                                                            \ Files: HANDLE >FID !FNAME @FNAME .FNAME                       \ Create file handle                                            -? : HANDLE ( "name" -- ; -- handle )  create                     -1 , ( fid)  0 c, max-path allot ( filename) ;                                                                                aka @ >FID ( handle -- fid )  \ Get fid from handle; -1=closed                                                                  \ Assign filename to handle & mark as closed                    : !FNAME ( a u handle -- )  >r  -blanks                           max-path min  r>  dup on  cell+ pack  count upper ;                                                                           \ Get filename                                                  : @FNAME ( handle -- a u )  cell+ count ;                                                                                       \ Display filename                                              : .FNAME ( handle -- )  @fname type space ;                     \ Files: ?OPENERR FOPEN (FOPEN)                                 : ?OPENERR ( handle ior -- )                                      dup if                                                            swap  cr .fname  $FF and  cond                                    2  of  ." file not found"  else                                 3  of  ." path not found"  else                                 4  of  ." too many open files"  else                            5  of  ." access denied"  else                                  .  ." open error"                                             cont  .abort                                                  then  2drop ;                                                                                                                 : FOPEN ( fam handle -- ior )                                     tuck  @fname rot open-file  tuck  0<> or  rot ! ;                                                                             : (FOPEN) ( fam handle -- )  tuck  fopen  ?openerr ;            \ Files: WRTCHK FMAKE (FMAKE) (?FMAKE)                          variable WRTCHK  wrtchk on          \ overwrite check                                                                           : FMAKE ( fam handle -- ior )                                     tuck  @fname rot create-file  tuck  0<> or  rot ! ;                                                                           : (FMAKE) ( fam handle -- )  tuck  fmake  ?openerr ;                                                                            : (?FMAKE) ( fam handle -- )                                      wrtchk @ if ( overwrite check )                                   dup @fname  r/o open-file  0= if                                  close-file  beep  over  cr .fname                               ." exists - overwrite? "  y/n 0= if  .abort  then             then  drop                                                    then  (fmake) ;                                                                                                               \ Files: (?FOPEN) FCLOSE                                        \ Flag=true if file exists, zero if created                     : (?FOPEN) ( fam handle -- flag )                                 2dup fopen                \ attempt file open                   if  (fmake)  false  end   \ attempt create                      2drop  true ;             \ success                                                                                           : FCLOSE ( handle -- ior )                                        dup >fid  swap on  -1 of  0  end  close-file ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                \ Files: IFILE OFILE .IFILE .OFILE IFID OFID                    handle IFILE  \ input file handle                               handle OFILE  \ output file handle                                                                                              : .IFILE ( -- )  ifile .fname ;                                 : .OFILE ( -- )  ofile .fname ;                                                                                                 : IFID ( -- fid )  ifile >fid ;                                 : OFID ( -- fid )  ofile >fid ;                                                                                                 integer ibuf  integer #ibuf  variable isiz  variable iptr       integer obuf  integer #obuf  variable osiz  variable optr       #256 to #ibuf  #256 to #obuf                                                                                                    : /ibuf ( -- )  ibuf iptr !  isiz off ;                         : /obuf ( -- )  obuf optr !  osiz off ;                         \ Files: OPENIN MAKEOUT OPENOUT ?OPENOUT                        \ Open existing file for input as IFILE                         : OPENIN ( fam -- )  ifile (fopen)  /ibuf ;                                                                                     \ Create file for output as OFILE                               : MAKEOUT ( fam -- )  ofile (?fmake)  /obuf ;                                                                                   \ Open existing file for output as OFILE                        : OPENOUT ( fam -- )  ofile (fopen)  /obuf ;                                                                                    \ Open/create file for output as OFILE                          \ Flag=true if file exists, zero if created                     : ?OPENOUT ( fam -- flag )  ofile (?fopen)  /obuf ;                                                                                                                                                                                                             \ Files: CLOSEIN CLOSEOUT CLOSEFILES                            defer oflush ( -- ior )  ' false is oflush                                                                                      \ Close IFILE - errors not reported                             : CLOSEIN ( -- )  ifile fclose drop ;                                                                                           \ Close OFILE - errors not reported                             : CLOSEOUT ( -- )                                                 ofid 1+ if oflush drop then  ofile fclose drop ;                                                                              \ Close files - errors not reported                             defer CLOSEFILES ( -- )                                                                                                         :noname ( -- )  closein  closeout ;  is closefiles                                                                              ' closefiles +is onerror  \ close files on error                \ Files: DELOUT SEEKIN SEEKOUT INPOS OUTPOS                     \ Close and delete OFILE - errors not reported                  : DELOUT ( -- )                                                   ofid  closeout  1+ if  ofile @fname  delete-file drop  then ;                                                                 \ Reposition IFILE                                              : SEEKIN ( ud -- )  ifid fseek /ibuf ;                                                                                          \ Reposition OFILE                                              : SEEKOUT ( ud -- )  oflush 4 ?ferror  ofid fseek ;                                                                             \ Get IFILE position                                            : INPOS ( -- ud )  ifid fpos  isiz @  0 d- ;                                                                                    \ Get OFILE position                                            : OUTPOS ( -- ud )  ofid fpos  osiz @  0 d+ ;                   \ Files: READ WRITE READLN WRITELN FLUSHOUT                     \ Read binary from IFILE                                        : READ ( a u1 -- a u2 )  ifid fread ;                                                                                           \ Write binary to OFILE                                         : WRITE ( a u -- )  ofid fwrite ;                                                                                               \ Read text from IFILE  n: 0=EOF -1=EOL 1=EOL not recv'd        : READLN ( a u1 -- a u2 n )  ifid freadln ;                                                                                     \ Write text to OFILE                                           : WRITELN ( a u -- )  ofid fwriteln ;                                                                                           \ Flush OFILE to disk                                           : FLUSHOUT ( -- )                                                 oflush  ofid flush-file  or 4 ?ferror ;                       \ Bread: READCHR                                                #ibuf reserve to ibuf  /ibuf                                                                                                    : ifill ( -- )  /ibuf  ibuf #ibuf read  isiz !  drop ;                                                                          label rdb  \ read char in A, NC if none                           isiz lhld  l a mov  h ora  1 $ jnz  c: ifill ;c  1 $:           isiz lhld  l a mov  h ora  2 $ jz  h dcx  isiz shld             iptr lhld  m a mov  h inx  iptr shld  stc  2 $:  ret          end-code                                                                                                                        \ Read character from IFILE buffered                            code READCHR ( -- char -1 | 0 )                                   rdb call  0 h lxi  h d mov  a e mov  1 $ jnc                    d push  h dcx  1 $:  1push  end-code                                                                                          \ Bread2: READ                                                  [undefined] rdb [if] _Bread [then]                                                                                              \ Read binary from IFILE buffered                               -? code READ ( a u -- a u2 )                                      d pop  h pop  h push  b push  0 b lxi                         1 $:  e a mov  d ora  2 $ jz                                      h push  d push  rdb call  d pop  h pop  2 $ jnc                 a m mov  h inx  b inx  d dcx  1 $ jmp                         2 $:  c l mov  b h mov  b pop  1push  end-code                                                                                                                                                                                                                                                                                                                                                                                                                  \ Bread2: READLN                                                \ Read text from IFILE buffered                                 -? code READLN ( a u -- a u2 n )  \ n: 0=EOF -1=EOL 1<>EOL        d pop  h pop  h push  b push  0 b lxi  e a mov  d ora           1 $ jz  8 $ call  1 $ jnc  $1A cpi  3 $ jnz  9 $ call         1 $:  0 h lxi  7 $ jmp                                          2 $:  8 $ call  5 $ jnc         \ get byte                      3 $:  $0A cpi  6 $ jz                                                 $1A cpi  4 $ jnz  9 $ call  5 $ jmp                       4 $:  $0D cpi  2 $ jz           \ skip CR                         a m mov  h inx  b inx  d dcx  e a mov  d ora  2 $ jnz         5 $:  1 h lxi  7 $ jmp  6 $:  -1 h lxi                          7 $:  c e mov  b d mov  b pop  2push                            8 $:  h push  d push  rdb call  d pop  h pop  ret               9 $:  c: ifid fsize seekin ;c  ret                              end-code                                                        \ Bwrite: WRITECHR                                              #obuf reserve to obuf  /obuf                                                                                                    :noname ( -- ior )                                                obuf osiz @ ofid write-file  /obuf ; is oflush                                                                                label wrb  \ write char in A                                      psw push  addr #obuf lhld  xchg  osiz lhld  cmpu call           1 $ jnz  c: oflush 4 ?ferror ;c  1 $:                           optr lhld  psw pop  a m mov  h inx  optr shld                   osiz lhld  h inx  osiz shld  ret  end-code                                                                                    \ Write character to OFILE buffered                             code WRITECHR ( char -- )                                         d pop  e a mov  wrb call  next  end-code                                                                                      \ Bwrite2: WRITE WRITELN                                        [undefined] wrb [if] _Bwrite [then]                                                                                             \ Write binary to OFILE buffered                                -? code WRITE ( a u -- )                                          d pop  h pop  1 $:  e a mov  d ora  2 $ jz                      m a mov  h push  d push  wrb call  d pop  h pop                 h inx  d dcx  1 $ jmp  2 $:  next  end-code                                                                                   \ Write text to OFILE buffered                                  -? : WRITELN ( a u -- )  write  (cr) write ;                                                                                                                                                                                                                                                                                                                                                    \ Random: SEED RAND RANDOM                                      \ Multiply doubles. Signed or unsigned.                         : D* ( d|ud1 d|ud2 -- d|ud3 )                                     rot 2>r 2dup um* rot r> * + rot r> * + ;                                                                                      \ LCS generator from Turbo-C                                                                                                    2variable SEED  1. seed 2!                                                                                                      \ Get random number                                             : RAND ( -- u )                                                   seed 2@  #22695477. d*  1. d+  tuck  seed 2! ;                                                                                \ Get random number between 0 and u-1                           : RANDOM ( u -- 0..u-1 )  rand um* nip ;                                                                                        \ Shuffle: SHUFFLE                                              \ Shuffle cells                                                                                                                 [undefined] RANDOM [if] _Random [then]                                                                                          : SHUFFLE ( adr count -- )                                        begin dup while >r                                                dup r@ random cells +                                           2dup @ swap @  rot ! over !                                     cell+  r> 1-                                                  repeat 2drop ;                                                                                                                                                                                                                                                                                                                                                                                \ Qsort: PRECEDES QSORT                                         \ Quicksort addr/cells (adapted from Wil Baden)                 defer PRECEDES ( x1 x2 -- f )  \ comparison                                                                                     -? : q ( lo hi -- )  2dup  over -  u2/                            [ -1 cells ] literal  and  + @ >r  2dup swap  begin               begin dup @  r@ precedes while cell+ repeat swap                begin r@ over @ precedes while cell- repeat swap                2dup u< not if  over @ over @  3 pick !  over !                   swap cell-  swap cell+  then  2dup u<                       until  rdrop  rot  2over 2over - + > if 2swap then              2dup u< if recurse else 2drop then                              2dup u< if recurse end  2drop ;                                                                                               : SORT ( adr siz -- )                                             dup if  1- cells over + q  end  2drop ;  behead q q           \ Dos1: (.FCB) @FCBATTR !FCBATTR                                \ Create filename spec from FCB/user                            : (.FCB) ( fcb user -- adr u )                                    >r  <#  #11 tuck + swap 0 ?do  i #3 = if [char] . hold then     dup c@ $7F and  dup bl > and  ?dup if hold then  1-  loop       [char] : hold  r> 0  over 255 - if #s then  rot c@ ?dup         if [char] @ + hold then  #>  [char] : skip  [char] . trim ;                                                                   \ Get/set FCB attributes  bit 0 = f1' etc                       : @FCBATTR ( fcb -- x )                                           0 swap 1+ #11 over + do  2* i c@ $7F > abs +  -1 +loop ;                                                                      : !FCBATTR ( x fcb -- )  1+ #11 bounds do  0 2 um/mod             i c@ rot if $80 or else $7F and then i c!  loop drop ;                                                                                                                                        \ Disk: GETDPB GETALLOC GETDSK SELDSK RESETDISK DISKSIZE        : GETDPB   ( -- dpb )    0 #31 fdos drop ;                      : GETALLOC ( -- alloc )  0 #27 fdos drop ;                                                                                      \ Get/select current drive  0=A 1=B etc                         : GETDSK ( -- dsk )  0 #25 bdos ;                               : SELDSK ( dsk -- )  #14 bdos drop ;                                                                                            \ Reset drives - use before disk change. Be aware DOS           \ and CP/M versions of the function work differently.           : RESETDISK ( -- )  0 #13 bdos drop ;                                                                                           \ Get disk-size on drive n  0=default 1=A 2=B etc               : DISKSIZE ( n -- ud )                                            getdsk >r  >drv seldsk  getdpb                                  dup 3 + c@ 1+ $80 *  swap 5 + @ 1+ um*  r> seldsk ;           \ Disk: DISKFREE                                                \ Get freespace/size on drive n  0=default 1=A 2=B etc          : DISKFREE ( n -- ud )                                            getdsk >r  >drv seldsk  $80 setdma  dosver nip $30 < if           getdpb  2+ dup c@  swap 3 +  @ 1+  getalloc ( bsh max alloc)    ;c  ready  c l mov  b h mov  b pop  xthl  0 d lxi               1 $:  b push  b ldax  8 b mvi  2 $:  ral  3 $ jc  d inx         3 $:  a c mov  h dcx  l a mov  h ora  4 $ jz  c a mov           b dcr  2 $ jnz  b pop  b inx  1 $ jmp  4 $:  b pop  b pop       h pop  xchg  5 $:  a ora  l a mov  ral  a l mov  h a mov        ral  a h mov  d a mov  ral  a d mov  e dcr  5 $ jnz             $80 shld  d a mov  $82 sta  check  c:                         else  getdsk #46 bdos drop  then  $80 rec@  r> seldsk ;                                                                                                                                                                                                       \ Timeconv: H:M:S Y-M-D D/M/Y M/D/Y                             \ Convert time to string                                        : H:M:S ( sec min hour -- a u )  swap rot  <#                     2 0 do  0 # # 2drop  [char] : hold  loop  0 # #  #> ;                                                                         \ Convert date to string                                        : Y-M-D ( day mon year -- a u )  swap rot  <#                     2 0 do  0 # # 2drop  [char] - hold  loop  0 # # # # #> ;                                                                      \ Convert date to string                                        : D/M/Y ( day mon year -- a u )  <#  0 # # # #                    2 0 do  2drop  [char] / hold  0 # #  loop  #> ;                                                                               \ Convert date to string                                        : M/D/Y ( day mon year -- a u )  rot swap d/m/y ;                                                                               \ Timeconv: $MONTH D-MMM-Y                                      \ Convert month to string                                       : $MONTH ( n -- a u )                                             1- 3 *  s" JanFebMarAprMayJunJulAugSepOctNovDec" drop + 3 ;                                                                   \ Convert date to string                                        : D-MMM-Y ( day mon year -- a u )  <#                             0 # # # # 2drop  bl hold  $month shold  bl hold  0 #s  #> ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   \ Timepack: PACKTIME UNPACKTIME PACKDATE UNPACKDATE             \ Pack time in MSDOS format                                     : PACKTIME ( sec min hour -- time )  #11 lshift                   swap #63 and  5 lshift  or  swap 2/ #31 and  or ;                                                                             \ Unpack MSDOS format time                                      : UNPACKTIME ( time -- sec min hour )  dup #31 and                2*  swap 5 rshift  dup #63 and  swap 6 rshift ;                                                                               \ Pack date in MSDOS format                                     : PACKDATE ( day mon year -- date )  #1980 -                      9 lshift  swap #15 and  5 lshift  or  swap #31 and  or ;                                                                      \ Unpack MSDOS format date                                      : UNPACKDATE ( date -- day mon year )  dup #31 and                swap 5 rshift  dup #15 and  swap 4 rshift #1980 + ;           \\ Clock: @TIME @DATE !TIME !DATE                               \ Get current time/date                                         : @TIME ( -- sec min hour )                                       $2C doscall  'DH c@  'CX c@  'CH c@ ;                                                                                         \ Set current time/date                                         : !TIME ( sec min hour -- ior )                                   'CH c!  'CX c!  'DH c!  0 'DX c!  $2D doscall  'AX c@ >ior ;                                                                  : @DATE ( -- day mon year )                                       $2A doscall  'DX c@  'DH c@  'CX @ ;                                                                                          : !DATE ( day mon year -- ior )                                   'CX !  'DH c!  'DX c!  $2B doscall  'AX c@ >ior ;                                                                                                                                             \ Filematch: DTA.FCB DTA.ATTR DTA.NAME                          [undefined] @FCBATTR [if] _Dos1 [then]                                                                                          integer DTA.FCB ( -- adr )  $80 to dta.fcb                                                                                      -? create du  0 , ( drv)  #255 , ( usr)                                                                                         -? : fn ( fcb fn# -- ior )                                        du cell+ @ setusr  bdos  rstusr  dup 4 < if  dup 5              lshift  $80 +  to dta.fcb  then  #255 =  #18 and  >ior ;                                                                      \ Matched file data                                             : DTA.ATTR ( -- attr )   dta.fcb @fcbattr ;                     : DTA.NAME ( -- adr u )  dta.fcb du 2@ 2 pick c! (.fcb) ;                                                                                                                                       \ Filematch: FINDFIRST FINDNEXT                                 \ Find first matching file. Uses default DMA address.           : FINDFIRST ( a u attrib -- ior )                                 >r  $80 setdma  >fcb  over c@  r> if  2drop                     [char] ? over c!  255 0  then  du 2!  #17 fn ;                                                                                \ Find next matching file                                       : FINDNEXT ( -- ior )  0 #18 fn ;                                                                                               behead du fn                                                                                                                                                                                                                                                                                                                                                                                                                                                    \ Wildexp: FNAMES FINDALL +FNAME /FNAMES                        [undefined] FINDFIRST [if] _Filematch [then]                                                                                    create FNAMES ( -- adr )  here , ( current)  here , ( top)                                                                      \ Build a list of filenames at HERE matching adr u.  ior=none   : FINDALL ( adr u attrib -- ior )                                 findfirst  dup if end  ( 0)  here dup fnames 2!                 begin  dta.name s,  findnext until  0 c, ;                                                                                    \ Get next filename from list                                   : +FNAME ( -- adr u true | false )                                fnames @ count  dup if  2dup + fnames !  -1  end  nip ;                                                                       \ Reset +FNAME to point to first filename in list               : /FNAMES ( -- )  fnames cell+ @ fnames ! ;                     \ Fileattr: @FILESTAMP !FILESTAMP @FILEATTR !FILEATTR           \ Get disk file packed timestamp                                \ : @FILESTAMP ( fid -- date time ior )                                                                                         \ Set disk file packed timestamp                                \ : !FILESTAMP ( date time fid -- ior )                                                                                         \ Get disk file attributes                                      : @FILEATTR ( a u -- attr ior )  >fcb setusr  dup #15 bdos >r     dup @fcbattr swap #16 bdos drop rstusr r> #255 = 2 and >ior ;                                                                 aka @fileattr FILE-STATUS ( a u -- attrib ior )                                                                                 \ Set disk file attributes                                      : !FILEATTR ( attr a u -- ior )  >fcb setusr                      tuck !fcbattr  #30 bdos  rstusr  #255 = 2 and >ior ;          \\ Env: ENVSEG GETENV                                           \ Return DOS environment segment                                : ENVSEG ( -- seg )  $2C @ ;                                                                                                    \ Search DOS environment for string a u.  Return null           \ terminated remainder.  Null not included in count.            : GETENV ( a u -- seg zadr len true | false )                     2>r  envseg  dup sseg !                                         0  begin  2dup @l  while  1+  repeat  2+                        r@  0  rot  2r>  caps search                                    if  rot /string  drop zcount  true                              else  2drop 2drop  0  then  cseg sseg ! ;                                                                                                                                                                                                                                                                                     \\ Exec:                                                        [undefined] GETDTA [if] _Dos1 [then]                            [undefined] GETENV [if] _Env  [then]                            warning @  warning off                                          create pb  #14  allot  \ parameter block                        create ct  #128 allot  \ command tail                           create f1  #37  allot  \ fcb1                                   create f2  #37  allot  \ fcb2                                                                                                   : fcb! ( zadr fcb  -- zadr' )                                     'DI !  'SI !  cseg 'ES !  1 'AX c!  $29 doscall  'SI @ ;                                                                      : !fcb ( -- )                                                     ct 1+  f1 fcb!  f2 fcb! drop                                    cseg f1 [ pb #6 + ]  literal 2!                                 cseg f2 [ pb #10 + ] literal 2! ;                             \\ Exec:                                                        : (exec) ( a u seg zadr flag -- ior )                             getdta 2>r                                                      >r  2swap                                                       pb 14 erase  cseg ct [ pb 2+ ] literal 2!                       ct 1+ 0  2 pick  r@ and if  s" /C "  2swap +string  then        +string  dup ct c!  + $0D swap c!                               r> 0= if !fcb then                                              'DX !  'DS !  pb 'BX !  cseg 'ES !  $4B00 'AX !                 $21 intcall  doserr?                                            2r> setdta ;                                                                                                                  warning !                                                                                                                                                                                                                                                       \\ Exec: EXEC SHELL RETCODE                                     \ Execute program                                               : EXEC ( param u prog u -- ior )                                  >fname 1+  cseg swap  false (exec) ;                                                                                          \ Shell to DOS with optional command                            : SHELL ( a u -- ior )                                            s" COMSPEC=" getenv and                                         if  true (exec)  end  drop  #255 >ior ;                                                                                       \ Get subprocess return code                                    : RETCODE ( -- type code )                                        $4D doscall  'AH c@  'AX c@ ;                                                                                                 behead pb (exec)                                                                                                                \\ Video1: text colors                                          0  constant BLACK       1  constant BLUE                        2  constant GREEN       3  constant CYAN                        4  constant RED         5  constant MAGENTA                     6  constant BROWN       7  constant LTGRAY                      8  constant GRAY        9  constant LTBLUE                      #10 constant LTGREEN    #11 constant LTCYAN                     #12 constant LTRED      #13 constant LTMAGENTA                  #14 constant YELLOW     #15 constant WHITE                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      \\ Video1: BORDER HI -HI BLINK -BLINK @CURSOR !CURSOR -CURSOR   \ Set text border color                                         : BORDER ( n -- )  'BX !  $B00 'AX !  $10 intcall ;                                                                             \ Set video attribute                                           -? : xa  ( and or -- )  attrib c@  or and  attrib c! ;          : HI     ( -- )  $FF $08 xa ;                                   : -HI    ( -- )  $F7 0   xa ;                                   : BLINK  ( -- )  $FF $80 xa ;                                   : -BLINK ( -- )  $7F $00 xa ;  behead xa xa                                                                                     \ Cursor get/set/disable                                        : @CURSOR ( -- x )  $F00 'AX !  $10 intcall  $300 'AX !           $10 intcall  'CX @ ;                                          : !CURSOR ( x -- )  'CX !  $100 'AX !  $10 intcall ;            : -CURSOR ( -- )  $2000 !cursor ;                               \\ Video2: @VMODE !VMODE @VPAGE !VPAGE                          \ Get/set video mode                                            : @VMODE ( -- n )  $F00 'AX !  $10 intcall  'AX c@ ;            : !VMODE ( n -- )  $FF and 'AX !  $10 intcall ;                                                                                 \ Get/set active video page                                     : @VPAGE ( -- n )  $F00 'AX !  $10 intcall  'BH c@ ;            : !VPAGE ( n -- )  dup $106 c!  $500 + 'AX !  $10 intcall ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \\ Timing1: /TIMER TIMER TICKS>MS .TIMER                        \ Get BIOS ticks  1 tick = 54.9254 mS                           aka ticks /TIMER ( -- d )  \ Reset timer                                                                                        \ Get elapsed time in ticks (24 hours max)                      : TIMER ( d1 -- d2 )  ticks  2swap d-  dup 0< if                  ( cross midnight)  #1573040. d+  then ;                                                                                       \ Convert ticks to milliseconds                                 : TICKS>MS ( d1 -- d2 )  #14006 #255 m*/ ;                                                                                      \ Display elapsed time in milliseconds                          : .TIMER ( d -- )  timer ticks>ms (ud.) type ."  mS " ;                                                                                                                                                                                                         \\ Timing2: (uSEC) uSEC                                         \ Wait AL * 0.8381uS  Uses Timer 2                              label (USEC)  \ AL = 127 max                                      al ah mov  $61 # al in  $FC # al and                            1 # al or  here 2+ ju  al $61 # out                             pushf  cli  $90 # al mov  al $43 # out                          $61 # al in  ah al mov  al $42 # out                          1 $:  $61 # al in  $80 # al mov  al $43 # out                     $61 # al in  $42 # al in  al shl  1 $ jnc                       popf  ret  end-code                                                                                                           \ Wait u * 0.8381uS  Uses Timer 2                               code USEC ( u -- )  \ u = 127 max                                 ax pop  (usec) ) call  next  end-code                                                                                                                                                         \\ Timing3: @TICKMODE !TICKMODE                                 \ Note: use /MS to recalibrate MS SOUND BEEP after changing     \ system tick timer mode                                                                                                        \ Get tick timer mode                                           : @TICKMODE ( -- 2|3 )  /ms  sys-vec #30 + @ ;                                                                                  \ Set tick timer mode  3=IBM-PC, 2=Win31/XP/other               : !TICKMODE ( n -- )  dup 2 or 3 = if                               2*  $30 +  $43 wait-tick pc!  $FF $40 pc!  $FF $40 pc!        end  drop ;                                                                                                                                                                                                                                                                                                                                                                                   \\ Device1: 8087? CPU?                                          \ Test/init 80x87                                               code 8087? ( -- flag )                                            ax ax sub  ax push  sp bp xchg  $E3DB , ( FINIT )               #100 # cx mov  1 $: 1 $ loop  $7ED9 , 0 c, ( FSTCW [BP] )       sp bp xchg  bx pop  bx bx or  2 $ jz  ax dec  2 $:  1push     end-code                                                                                                                        \ Get CPU type                                                  code CPU? ( -- n )  \ n= $86, $286, $386                          pushf  $86 # ax mov  sp push  bx pop  bx sp cmp  1 $ jnz        2 # ah mov  pushf  bx pop  $F0 # bh or  bx push  popf  pushf    bx pop  $F0 # bh and  1 $ jz  ah inc  1 $:  popf  1push       end-code                                                                                                                                                                                        \\ Device1: EH-KEYBOARD?                                        \ Enhanced keyboard hardware test                               : EH-KEYBOARD? ( -- flag )                                        $40 $96 c@l  $10 and  0<> ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   