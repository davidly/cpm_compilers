\ Information                                                   A full-screen editor for DX-Forth.  Based on the editor         from "Forth - A Text and Reference" by Kelly & Spies.                                                                           Usage:  n SED  ( edit screen n )                                          SED  ( edit screen where error occured )                                                                              Ctl-D  Right cursor   Ctl-Y  Delete line    Ctl-C  Next block   Ctl-S  Left cursor    Ctl-N  Insert line    Ctl-R  Prev Block   Ctl-E  Up cursor      Ctl-T  Erase to EOL   Ctl-L  Restore blk  Ctl-X  Down cursor    Ctl-A  Save line      Ctl-J  Jump to blk  Ctl-I  Tab cursor     Ctl-P  Restore line   Ctl-K  Update block Ctl-Q  Home cursor    Ctl-O  Open-up line   Ctl-V  Insert toggleCtl-G  Del next char  Ctl-W  Split line     Ctl-B  Redraw screenCtl-H  Del prev char  Ctl-F  Join line      Ctl-Z  Functions    Ctl-U  Exit editor    Esc    Graphic toggle                     \ Load block                                                    forth definitions  decimal  sys @  system                                                                                       cr ." loading 64x16 Screen Editor "  2 #screens 1- thru                                                                         forth definitions  decimal  sys !                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               \ Constants, variables                                          vocabulary EDITOR immediate  editor definitions                                                                                 \ integer C/L  64 to c/l  \ columns per line                    integer L/S  16 to l/s  \ lines per screen                      integer B/SCR  0 to b/scr  \ bytes per screen                   0  constant X           \ screen x offset                       0  constant Y           \ screen y offset                       4  constant TBS         \ tab size increment                                                                                    variable R#             \ cursor row position                   variable C#             \ cursor col position                   variable INS            \ insert flag                           variable QF             \ quit flag                             variable GF             \ graphics flag                                                                                         \ WAIT HI RNG? CHR?                                             \ Short pause                                                   : WAIT ( -- )  500 ms ;                                                                                                         \ Highest block number                                          : HI ( -- u )  #screens 1-  0 max ;                                                                                             \ Test if block u is within range                               : RNG? ( u -- u f )  dup 0 #screens within ;                                                                                    \ Test char printable                                           : CHR? ( c -- f )  dup 32 255 between swap 127 <> and ;                                                                                                                                                                                                                                                                         \ COPY COPIES                                                   \ Copy screen u1 to u2                                          : COPY ( u1 u2 -- )                                               swap block  swap buffer  b/buf cmove                            update  save-buffers ;                                                                                                        \ Copy u3 screens from screen u1 to u2                          : COPIES ( u1 u2 u3 -- )                                          ?dup if                                                           swap  2 pick -  >r  over +                                      r@ 0< if  swap  1  else  1-  -1  then                           r> 2swap do  i  2dup +  copy  over +loop                      then  2drop ;                                                                                                                                                                                                                                                 \ ?EXTEND EXPAND                                                \ Extend file if block u is not in range                        : ?EXTEND ( u -- )                                                rng? if  drop  end  1+ fileblocks ;                                                                                           \ Insert blank screen at block u                                : EXPAND ( u -- )                                                 dup  dup 1+ over                                                #screens  dup ?extend                                           swap - copies                                                   block b/buf blank update ;                                                                                                                                                                                                                                                                                                                                                                    \ SHRINK                                                        \ Delete screen u, copying it to buffer                         : SHRINK ( u -- )                                                 rng? if                                                           pad  dup b/scr +  b/scr cmove                                   dup 1+  swap over #screens  swap - copies                       #screens 1-  dup fileblocks                                     1-  scr @  umin  scr !                                        end  drop ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   \ !XY @XY CXY UP DN                                             \ Save cursor pos                                               : !XY ( y x -- )  c# !  r# ! ;                                                                                                  \ Get cursor pos                                                : @XY ( -- y x )  r# @  c# @ ;                                                                                                  \ Restore cursor pos                                            : CXY ( -- )  @xy x +  swap y +  at-xy ;                                                                                        \ ^E  move cursor up one position                               -? : UP ( -- )  r# @  0> if  -1 r# +!  cxy  then ;                                                                              \ ^X  move cursor down one position                             : DN ( -- )  r# @  l/s 1-  < if  1 r# +!  cxy  then ;                                                                           \ LFT RT HOM TAB                                                \ ^S  move cursor left one position                             : LFT ( -- )  c# @  0> if  -1 c# +!  cxy  then ;                                                                                \ ^D  move cursor right one position                            : RT ( -- )  c# @  c/l 1-  < if  1 c# +!  cxy  then ;                                                                           \ ^Q  Move cursor to home position                              : HOM ( -- )  0 0 !xy  cxy ;                                                                                                    \ ^I  Move cursor to next tab position                          : TAB ( -- )  tbs  c# @  over mod -  0 do  rt  loop ;                                                                                                                                                                                                                                                                           \ LSA LIN LEA SOL NL                                            \ Line start address                                            : LSA ( -- a )  pad  r# @  c/l *  + ;                                                                                           \ Current line                                                  : LIN ( -- a u )  lsa c/l ;                                                                                                     \ Line end address                                              : LEA ( -- a )  lin 1-  + ;                                                                                                     \ Move cursor to start of current line                          : SOL ( -- )  c# off  cxy ;                                                                                                     \ ^M  Move cursor to start of next line                         : NL ( -- )  sol dn ;                                                                                                           \ CP CBA LBA BELOW BLEFT                                        \ Cursor position address                                       : CP ( -- a )  lsa  c# @  + ;                                                                                                   \ Circular buffer address                                       : CBA ( -- a )  b/scr 2*  pad + ;                                                                                               \ Line buffer address                                           : LBA ( -- a )  cba  c/l + ;                                                                                                    \ Number chars from cur line to end circ buffer                 : BELOW ( -- n )  l/s  r# @  -  c/l *  b/scr + ;                                                                                \ Number chars from cursor to end-of-line                       : BLEFT ( -- n )  lea cp - ;                                                                                                    \ .LINE .LINES BORDER                                           \ Display line from cursor position to end                      : .LINE ( -- )                                                    clear-line  cp bleft 1+  -trailing type  cxy ;                                                                                \ Display all lines from current to end of screen               : .LINES ( -- )                                                   @xy  l/s r# @ do  i r# !  sol .line  loop  !xy  cxy ;                                                                         \\ Draw border                                                  : BORDER ( -- )                                                   x y 1- at-xy  c/l 1- 0  do                                        i  tbs 2*  mod if  [char] -  else  [char] !  then  emit       loop  [char] !  emit  0 y at-xy                                 l/s 0  do  i 2 .r  cr  loop ( cr  ." B:") ;                                                                                   \ MODE STAT .LB                                                 \ Display mode                                                  : MODE ( -- )                                                     10 0 at-xy  gf @ if  ." GFX  "  else ." Norm "  then            ins @ if  ." Ins"  else  ." Ovr"  then ;                                                                                      \ Display status line                                           : STAT ( -- )  0 0 at-xy  ." Scr "  scr @ .  space                20 0 at-xy  loadfile type ;                                                                                                   \ Display line buffer                                           : .LB ( -- )  x y 4 + 0 over 1- at-xy ." L:"                      at-xy  lba c/l type ;                                                                                                                                                                                                                                         \ .BLK .SCR ~INS ~ESC CLS                                       \ Display status line and screen lines                          : .BLK ( -- )  @xy  hom .lines  !xy  cxy ;                                                                                      \ ^B  Redraw screen                                             : .SCR ( -- )  page  mode  stat  .lb   wait wait  .blk ;                                                                        \ ^V  Toggle insert mode                                        : ~INS ( -- )  ins @ not ins !  .scr ;                                                                                          \ ESC  Toggle graphic mode                                      : ~ESC ( -- )  beep ( gf @ not gf !  .scr ) ;                                                                                   \ Clear screen                                                  : CLS ( -- )  pad b/scr blank  .blk ;                                                                                           \ CLB CLL @BLK !BLK RESTORE                                     \ Clear circular buffer                                         : CLB ( -- )  pad b/scr +  b/scr c/l +  blank ;                                                                                 \ Clear one line buffer                                         : CLL ( -- )  lba c/l blank ;                                                                                                   \ Load block                                                    : @BLK ( -- )  scr @ block  pad b/scr  2dup blank                 b/buf min  cmove ;                                            \ Save block and update                                         : !BLK ( -- )  pad  scr @ buffer  dup b/buf blank                 b/scr b/buf min  cmove>  update ;                                                                                             \ ^L  Reload block and display it                               : RESTORE ( -- )  @blk page .blk ;                              \ +BLK -BLK ?KEY INP                                            \ ^C  Go to next block                                          : +BLK ( -- )  scr @  hi < if  1 scr +!  restore  then ;                                                                        \ ^R  Go to previous block                                      : -BLK ( -- )  scr @  0> if  -1 scr +!  restore  then ;                                                                         \ Get key and display if printable                              : ?KEY ( -- c )                                                   key  upcase  dup chr? if  dup emit  then ;                                                                                    \ Get input string  0=empty                                     : INP ( -- a u -1 | 0 )                                           here  dup 20 accept  bl skip dup if  -1  end  and ;                                                                                                                                           \ CLM CLM2 CLRMSG ENDMSG BUSY                                   \ Clear space for msg                                           : CLM ( y-offs -- )                                               y + 0 swap at-xy  clear-line ;                                                                                                \ Clear space for msg2                                          : CLM2 ( -- )  1 clm ;                                                                                                          \ Clear space for msgs                                          : CLRMSG ( -- )  clm2  0 clm ;                                                                                                  \ Clear messages and restore display                            : ENDMSG ( -- )  restore  cxy ;                                                                                                 : BUSY ( -- )  clrmsg  ." Busy ..." ;                                                                                           \ FUNC                                                          \ ^Z  Function select                                           : FUNC ( -- )                                                     clrmsg ." *** SCREEN: (I)nsert, (D)elete "                      clm2   ."     CLEAR:  (B)uffer, (S)creen ? "                    ?key cond                                                         [char] I of  busy  scr @ expand  restore  else                  [char] D of  busy  scr @ shrink  restore  else                  [char] B of  clb  else                                          [char] S of  cls  hom  else                                     drop                                                          cont  endmsg ;                                                                                                                                                                                                                                                                                                                \ ?EXIT JMP                                                     \ ^U  Quit editor                                               : ?EXIT ( -- )                                                    clrmsg ." *** EXIT: (S)ave, (Q)uit ? "  ?key                    [char] S of  update  flush  qf on  end                          [char] Q of  empty-buffers  qf on  end                          drop  endmsg ;                                                                                                                                                                                \ ^J  Jump to block                                             : JMP ( -- )                                                      begin                                                             clrmsg ." *** JUMP: Screen (0-" hi  0 .r  ." )? "               inp  0= if  endmsg  end  number?                              until drop  dup ?extend  scr !  hom  restore ;                                                                                \ (OPN) OPN DEOL                                                \ Open up line at cursor                                        : (OPN) ( -- )                                                    c# @  c/l <                                                     lea c@  bl =  and  if                                             cp dup 1+ bleft cmove>  bl cp c!                              end  beep ;                                                                                                                   \ ^O  Open up line at cursor                                    : OPN ( -- )  (opn)  .line ;                                                                                                    \ ^T  Delete from cursor to end of line                         : DEOL ( -- )  cp bleft 1+  dup spaces  cxy  blank ;                                                                                                                                                                                                            \ DEL UPD OCHR                                                  \ Delete char at cursor                                         : DEL ( -- )                                                      c# @  c/l < if                                                    cp 1+  cp  bleft cmove  bl lea c!  .line                      then ;                                                                                                                        \ ^K  Update and save screen                                    : UPD ( -- )                                                      !blk  clrmsg ." *** UPDATED BLOCK: "  scr @ .  wait  endmsg ;                                                                 \ Overtype char at cursor                                       : OCHR ( c -- )                                                   c# @  c/l < if                                                    dup emit  cp c!  c# @  c/l 1-  < if  1 c# +!  end  cxy        end  drop beep ;                                              \ ICHR BSP GET                                                  \ Insert char at cursor                                         : ICHR ( c -- )                                                   lea c@  bl = if  (opn)  ochr  .line  end  drop beep ;                                                                         \ Output character                                              : !CHR ( c -- )  ins @ if  ichr  end  ochr ;                                                                                    \ ^H  Backspace (delete prev character)                         : BSP ( -- )  c# @ if  lft  del  then ;                                                                                         \ ^P  Copy from one-line buffer                                 : GET ( -- )                                                      lba lin cmove  @xy  sol .line  !xy  cxy ;                                                                                                                                                     \ PUT KILL INSL                                                 \ ^A  Copy line to line buffer                                  : PUT ( -- )  lin lba swap cmove  .scr ;                                                                                        \ ^Y  Kill line, push to circular buffer                        : KILL ( -- )                                                     lin cba swap cmove  lin + lsa below cmove  .lines ;                                                                           \ ^N  Insert line from circular buffer                          : INSL ( -- )                                                     lin over + below cmove>  cba lin cmove  .lines ;                                                                                                                                                                                                                                                                                                                                              \ SPLIT JOIN                                                    \ ^W  Split line at cursor                                      : SPLIT ( -- )                                                    cp  dup below bleft +  c/l /string  cmove>                      cp c/l blank  .lines ;                                                                                                        \ ^F  Join line with next                                       : JOIN ( -- )                                                     lin + c/l  bl skip  dup if                                        bleft 1+ min  cp swap cmove  .lines                           end  2drop deol ;                                                                                                                                                                                                                                                                                                                                                                             \ 'CMD                                                          create 'CMD                                                     ] put      ( A save line )      .scr     ( B redraw scr  )        +blk     ( C next blk  )      rt       ( D right curs  )        up       ( E up curs   )      join     ( F join line   )        del      ( G del char  )      bsp      ( H destruct bs )        tab      ( I tab key   )      jmp      ( J jump to blk )        upd      ( K update    )      restore  ( L restore blk )        nl       ( M cr        )      insl     ( N insert line )        opn      ( O open txt  )      get      ( P restore line)        hom      ( Q home curs )      -blk     ( R prev block  )        lft      ( S left curs )      deol     ( T delet to EOL)        ?exit    ( U exit      )      ~ins     ( V insert toggl)        split    ( W split line)      dn       ( X down curs   )        kill     ( Y kill line )      func     ( Z function    )        ~esc     ( \ graphic   )  [                                   \ INIT CMD                                                      \ Initialisation                                                : INIT ( scr offs -- )                                            dup  0 b/buf within  and      \ check offset                    c/l /mod  swap !xy                                              0 tuck max  hi min  scr 2!    \ check scr  clear offset         clb cll                       \ clear buffers                   ins on  gf off  decimal       \ set mode                        restore                       \ load and display scr            cxy ;                         \ position cursor                                                                               \ Execute command n                                             : CMD ( n -- )  1-  2*  'cmd +  @  execute ;                                                                                                                                                                                                                    \ MAPKEY                                                        \ Map special keys                                              : KMAP ( c -- c' )                                                $14E c@ of   8  end   \ backspace                               $14F c@ of   5  end   \ up arrow                                $150 c@ of  24  end   \ down arrow                              $151 c@ of   4  end   \ right arrow                             $152 c@ of  19  end   \ left arrow                              127     of   7  end   \ delete                                \  338     of  22  end   \ insert                               \  329     of  18  end   \ page up                              \  337     of   3  end   \ page down                            \  327     of  17  end   \ home                                   ( c) ;                                                                                                                                                                                        \ (E)                                                           \ Edit screen/offset                                            : (E) ( scr offs -- )                                             init  qf off                                                    begin                                                             key  gf @ if                                                      dup 27 = if  drop ~esc  else  !chr  then                      else                                                              kmap  dup 1 28 within if  cmd                                   else                                                              dup chr? if  !chr  else  drop beep  then                      then                                                          then  qf @                                                    until  l/s 0 do cr loop ;                                                                                                                                                                     \ IMPORT EXPORT                                                 \ Copy screens n1-n2 from secondary file                        : IMPORT ( n1 n2 -- )                                             scr @  -rot  1+ swap ?do                                          dup expand                                                      swap-file  i block drop                                         swap-file  dup buffer drop  update flush                        1+  dup scr !                                                 loop drop ;                                                                                                                   \ Copy screens n1-n2 to secondary file                          : EXPORT ( n1 n2 -- )                                             swap-file  import  swap-file ;                                                                                                                                                                                                                                \ SED                                                           forth definitions  editor                                                                                                       \ Edit screen u or where LOAD error occured                     -? : SED ( ? -- )                                                 b/scr 0= if  b/buf to b/scr  then                               application unused  b/scr 2* c/l +  u< abort" out of memory"    0 ?extend  depth if  0  else  scr 2@ swap  then  (e) ;                                                                        \ aka SED EDIT                                                                                                                  behead x (e)                                                                                                                    forth                                                                                                                                                                                           