\ Miscellaneous functions                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       \ 0<= 0>= <= >= U<= U>=                                         : 0<= ( n -- flag )  0> 0= ;                                    : 0>= ( n -- flag )  0< 0= ;                                    : <=  ( n1 n2 -- flag )  > 0= ;                                 : >=  ( n1 n2 -- flag )  < 0= ;                                 : U<= ( u1 u2 -- flag )  u> 0= ;                                : U>= ( u1 u2 -- flag )  u< 0= ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                \ 3DUP NDROP ?NEGATE ?DNEGATE                                   \ Duplicate a triple number                                     : 3DUP ( x1 x2 x3 -- x1 x2 x3 x1 x2 x3 )  dup 2over rot ;                                                                       \ Drop n cells from stack                                       code NDROP ( xn..x1 n -- )                                        h pop  h dad  sp dad  sphl  next                              end-code                                                                                                                        \ Negate n1/d1 if n is negative  (FIG: +- D+-)                  : ?NEGATE ( n1 n -- n2 )  0< if negate then ;                   : ?DNEGATE ( d1 n -- d2 )  0< if dnegate then ;                                                                                                                                                                                                                                                                                 \ UNDER UNDER+ ASHIFT PLUCK                                     \ : UNDER ( a b -- a a b )  over swap ;                         code UNDER ( a b -- a a b )                                       h pop  d pop  d push  2push  end-code                                                                                         \ : UNDER+ ( a b x -- a+x b )  rot + swap ;                     code UNDER+ ( a b x -- a+x b )                                    d pop  h pop  xthl  d dad  xthl  1push  end-code                                                                              \ : ASHIFT ( n1 u -- n2 )  0 ?do 2/ loop ;                      code ASHIFT ( n1 u -- n2 )                                        d pop  h pop  e inr  1 $:  e dcr  hpush jz                      ' 2/ 2+ @ call  1 $ jmp  end-code                             \ : PLUCK ( -- x )  2 pick ;                                    code PLUCK ( -- x )                                               2 cells h lxi  sp dad  ' @ 1+ jmp  end-code                   \ SPLIT /SPLIT /CHAR \CHAR \STRING                              : SPLIT ( a u c -- a2 u2 a3 u3 )  \ split at char                 >r 2dup r> scan 2swap 2 pick - ;                                                                                              : /SPLIT ( a u n -- a2 u2 a3 u3 )  \ split at index               >r over r@ 2swap r> /string 2swap ;                                                                                           : /CHAR ( a u -- a2 u2 char )  \ extract char from start          1 /string over 1- c@ ;                                                                                                        : \CHAR ( a u -- a2 u2 c )  \ extract char from end               1- 2dup + c@ ;                                                                                                                : \STRING ( a1 u1 u -- a2 u2 )  \ return u right-most chars       >r + r@ - r> ;                                                                                                                \ DIGIT? ALPHA?                                                 : DIGIT? ( char -- flag )  \ true if char decimal digit           [char] 0 - #10 u< ;                                                                                                           : ALPHA? ( char -- flag )  \ true if char alphabetical            upcase [char] A - #26 u< ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    \ Number utilities                                              \ Numeric string                                                : UD.   ( ud -- )  (ud.) type space ;                           : UD.R  ( ud n -- )  >r (ud.) r> s.r ;                                                                                          \ Hex formatted                                                 : (H.)  ( u -- adr len )  [ 2 cells ] literal (h.n) ;           : (HW.) ( u -- adr len )  4 (h.n) ;                             : (HB.) ( u -- adr len )  2 (h.n) ;                                                                                             : (HD.) ( ud -- adr len )                                         (h.) shold  (h.)  [ -2 cells ] literal /string ;                                                                                                                                                                                                                                                                              \ Number utilities                                              \ Right-justified numeric string                                : (D.R) ( d w -- adr len )  >r (d.) r> (s.r) ;                  : (U.R) ( u w -- adr len )  0 swap (d.r) ;                      : (.R)  ( n w -- adr len )  swap s>d rot (d.r) ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                \ /SIGN /NUMBER >INT                                            \ Skip leading sign; leave true if exists and negative          \ Defined in kernel                                             : /SIGN ( a u -- a' u' f )                                        over c@  dup [char] + =  swap [char] - =                        dup >r  or over 0<> and  negate /string  r> ;                                                                                 \ Convert string to double number; stop at invalid char         \ Defined in kernel                                             : /NUMBER ( a u -- a' u' d|ud )                                   /sign >r 0 0 2swap >number 2swap r> if dnegate then ;                                                                         \ Convert string to integer; no checks                          : >INT ( a u -- n|u )  /number 2nip drop ;                                                                                                                                                      \ NUMBER? (old version)                                         : NUMBER? ( c-addr u -- d true | 0 )                              /sign >r  0 0 2swap >number  dpl on  begin                        dup if  over c@ bl <> and  then                               dup while                                                         over c@  dup [char] : =                                         swap [char] +  [char] 0  within  or                             0= if  rdrop 2drop 2drop 0  end                                 1 /string  dpl off  >number                                   repeat  2drop                                                   r> if dnegate then  true ;                                                                                                    \ Patch into forth interpreter                                  \  ' NUMBER?  SYS-VEC #18 + @  !  PROTECT                                                                                                                                                       \ NUMBER? (embedded '.')                                        \ DPL returns #places after dec.pt or -1 if none                : NUMBER? ( c-addr u -- d true | 0 )                              /sign >r  0 0 2swap  ?dup if                                      >number  dpl on  dup if ( not end)                                over c@ [char] . =                                            while  1 /string  dpl off  >number  0= ?dup                     while  then  2drop  r> if dnegate then  -1  end               then  then  r> 2drop 2drop  0 ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               \ U-NUMBER S-NUMBER                                             \ convert numeric string to unsigned single integer             : U-NUMBER ( adr len -- u -1 | 0 )                                number? if  0= ?dup and  end  0 ;                                                                                             \ convert numeric string to signed single integer               : S-NUMBER ( adr len -- n -1 | 0 )                                number? if  over 0< xor 0= ?dup and  end  0 ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 \ +COMMA                                                        \ Add commas to numeric string                                  \ Uses HOLD buffer                                              : +COMMA ( a1 u1 -- a2 u2 )                                       <#  [char] . split  2swap shold                                 0  begin  over while  >r  \char                                   r>  2dup 3 = swap digit? and                                    if  [char] , hold  drop 0  then                                 swap hold  1+                                                 repeat  drop  #> ;                                                                                                            \ e.g. Pi 1e8 f* 0 (f.) >pad +comma cr type                                                                                                                                                                                                                                                                                     \ -COMMA                                                        \ Remove commas from numeric string  C.H.                       : -COMMA ( a u a2 -- a2 u2 )                                      0 2swap bounds ?do                                                i c@  [char] ,  - if                                              2dup +  i c@  swap c!  1+                                     then                                                          loop ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        \ -CHAR                                                         \ Remove char from string. Uses HOLD buffer.                    : -CHAR ( a u char -- a2 u2 )                                     >r  <#  begin  dup while  \char                                 r@ of  else  hold  then  repeat  #> rdrop ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   \ +DOT                                                          \ Add dot separators to numeric string                          \ Uses HOLD buffer                                              : +DOT ( a1 u1 -- a2 u2 )                                         0  <#  begin  over while                                          4 of  [char] . hold  0  then  1+                                >r  \char hold  r>                                            repeat drop  #> ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             \ RJUST (S.R) DP-ALIGN                                          \ Return string right-aligned as a2 u2. Uses HOLD buffer        : RJUST ( a u +n c -- a2 u2 )                                     >r  over - 0 max >r  <# shold  r> r> nhold  held ;                                                                            : (S.R) ( a u +n -- a2 u2 )  bl rjust ;                                                                                         \ Decimal-point align string                                    \ width= #places left of decimal pt; +n= #spaces required       : DP-ALIGN ( adr len width -- adr len +n )                        >r  2dup [char] . scan nip over -  r> + 0 max ;                                                                                                                                                                                                                                                                                                                                               \ FOR NEXT                                                      sys @  application                                              here ( xt)  [asm ready  \ NEXT                                    rpp lhld  m a mov  1 sui  a m mov  h inx  m a mov  0 sbi        a m mov  bran jnc  h inx  rpp shld  b inx  b inx  next          check asm]                                                                                                                    here ( xt)  [asm ready  \ FOR                                     d pop  d a mov  e ora  bran jz  d dcx  rpp lhld  h dcx          d m mov  h dcx  e m mov  rpp shld  b inx  b inx  next           check asm]                                                                                                                    system  checking off                                            : FOR  compile [ , ]  >mark  postpone begin ;  immediate        : NEXT  compile [ , ]  <resolve  postpone then ;  immediate     checking on  sys !                                              \ FOR NEXT (eForth)                                             sys @  application                                              here ( xt)  [asm ready  \ NEXT                                    rpp lhld  m a mov  1 sui  a m mov  h inx  m a mov  0 sbi        a m mov  bran jnc  h inx  rpp shld  b inx  b inx  next          check asm]                                                                                                                    system  checking off                                            : NEXT  compile [ , ]  <resolve ;  immediate                    : FOR  postpone >r  postpone begin ;  immediate                 : AFT  ( cs-drop) drop -1 bal +!  postpone ahead                  postpone begin  ( 1 cs-roll) swap ;  immediate                checking on  sys !                                                                                                                                                                                                                                              \ BL-SCAN BL-SKIP                                               \ Scan blank or control character                               code BL-SCAN ( c-addr1 u1 -- c-addr2 u2 )                         c l mov  b h mov  b pop  xthl  $20 e mvi  1 $:  c a mov         b ora  2 $ jz  e a mov  m cmp  2 $ jnc  h inx  b dcx            1 $ jmp  2 $:  xthl  b push  l c mov  h b mov  next           end-code                                                                                                                        \ Skip blank or control character                               code BL-SKIP ( c-addr1 u1 -- c-addr2 u2 )                         c l mov  b h mov  b pop  xthl  $20 e mvi  1 $:  c a mov         b ora  2 $ jz  e a mov  m cmp  2 $ jc  h inx  b dcx             1 $ jmp  2 $:  xthl  b push  l c mov  h b mov  next           end-code                                                                                                                                                                                        \ SCANW SKIPW                                                   \ As for SCAN/SKIP with exception if char is BL then            \ control characters (0..31) are treated as BL                                                                                  code SCANW ( c-addr1 u1 char -- c-addr2 u2 )                      d pop  c l mov  b h mov  b pop  xthl  1 $:  c a mov             b ora  3 $ jz  m d mov  e a mov  $20 cpi  2 $ jnz  d cmp        3 $ jnc  2 $:  d cmp  3 $ jz  h inx  b dcx  1 $ jmp             3 $:  xthl  b push  l c mov  h b mov  next  end-code                                                                          code SKIPW ( c-addr1 u1 char -- c-addr2 u2 )                      d pop  c l mov  b h mov  b pop  xthl  1 $:  c a mov             b ora  3 $ jz  m d mov  e a mov  $20 cpi  2 $ jz  d cmp         3 $ jnz  2 $:  d cmp  3 $ jc  h inx  b dcx  1 $ jmp             3 $:  xthl  b push  l c mov  h b mov  next  end-code                                                                          \ Misc functions                                                \ Input string of n chars max, return false if empty or blanks  : INPUT ( n -- c-addr u true | false )                            here  dup rot accept  bl skip  dup if  -1  end  and ;                                                                         \ Convert hex string to a double number                         : HEXNUMBER? ( c-addr u -- d -1 | 0 )                             base @ >r  hex number?  r> base ! ;                                                                                           \ Display n backspace characters                                : BACKSPACES ( n -- )  0 max  0 ?do  8 emit  loop ;                                                                                                                                                                                                                                                                                                                                             \ Exception tools                                               \ THROW exception code n if flag is non-zero                    : ?THROW ( flag n -- )  swap 0<> and throw ;                                                                                    \ Perform CATCH intercepting exception code n only              : ?CATCH ( xt n -- n )  >r catch dup r> <> over and throw ;                                                                     \ Intercepting a range of exception codes                       \  ['] do-it CATCH  case                                        \    x1  of  ...  endof  \ catch error x1                       \    x2  of  ...  endof  \ catch error x2                       \    dup throw           \ throw all others                     \  endcase                                                                                                                                                                                                                                                      \ DEFER tools                                                   sys @  system                                                   \ Add new behaviour to existing deferred word                   : +IS ( xt <name> -- )  >r  :noname  r> compile,                  ' >body  dup >r  @ compile,  postpone ;  r> ! ;                                                                               \ Compile current behaviour of a deferred word                  : DEFERS ( <name> -- )  ' >body @ compile, ;  immediate                                                                         sys !                                                                                                                                                                                                                                                                                                                                                                                                                                                           \ Stack tools                                                   \ Versions for use with turnkey applications.                                                                                   -? : ?STACK ( ? -- ? )                                            sp@  s0 @ 1+  pad  within abort" stack?"                        rp@  r0 @ 1+  fs0 @  within abort" r-stack?"                    fsp @  fs0 @ dup 1+ swap [ sys-vec #20 + ] literal              @ - within abort" f-stack?" ;                                                                                                 -? : .S ( ? -- ? )                                                cr  ?stack                                                      depth 0 ?do  depth i - 1- pick .  loop  ." <stack "             [defined] fdrop [if]                                            fdepth ?dup if                                                    0 do  fdepth i - 1- fpick fs.  loop  ." <f-stack "            then  [then] ;                                                \ Quad - DUM*                                                   \ Multiply doubles leaving quad. Unsigned.                      : DUM* ( ud1 ud2 -- uq )                                          2 pick over um* 2>r  3 pick um* 2>r  tuck                       um* 2>r  um*  0 2r> d+  2r@ d+  2dup 2r>                        du< if  r> 1+ >r  then  0 2r> d+ ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            \ Quad - DUM/MOD                                                \ Divide quad by double. Unsigned.                                                                                              -? 2variable d                                                                                                                  : DUM/MOD ( uq ud -- udrem udquot )                               d 2!  #32 0 do                                                    dup >r  2swap dup >r                                            d2*  2swap d2*  r> 0< dup d-                                    2dup d 2@ du< not  r> 0<  or                                    if  d 2@ d-  2swap 1 0 d+ 2swap  then                         loop  2swap ;                                                                                                                 behead d d                                                                                                                                                                                      \ Double - D* DU/MOD  high level                                \ Multiply doubles. Signed or unsigned.                         : D* ( d|ud1 d|ud2 -- d|ud3 )                                     rot 2>r 2dup um* rot r> * + rot r> * + ;                                                                                      \ Divide doubles. Unsigned.                                     : DU/MOD ( ud1 ud2 -- udrem udquot )                              0 0 2swap dum/mod ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \ Double - FD/MOD SD/REM                                        \ Divide doubles signed by unsigned. Floored.                   : FD/MOD ( d ud -- drem dquot )                                   2dup 2>r  2swap dup >r  dabs 2swap du/mod  r> 0< if             dnegate  2over or if  1. d-  2r@ 2rot d- 2swap  then            then  2r> 2drop ;                                                                                                             \ Divide doubles. Signed. Symmetric.                            : SD/REM ( d1 d2 -- drem dquot )                                  2 pick  2dup xor 2>r  dabs  2swap dabs  2swap du/mod  r>        0< if  dnegate  then  r> 0< if  2swap dnegate 2swap  then ;                                                                                                                                                                                                                                                                                                                                   \ Double operations                                             \ Memory                                                        : M+! ( n a -- )  dup >r 2@ rot m+ r> 2! ;                      : D+! ( d a -- )  dup >r 2@ d+ r> 2! ;                                                                                          \ Logical                                                       : DAND ( xd1 xd2 -- xd3 )  rot and >r and r> ;                  : DOR  ( xd1 xd2 -- xd3 )  rot or >r or r> ;                    : DXOR ( xd1 xd2 -- xd3 )  rot xor >r xor r> ;                  : DINVERT ( xd1 -- xd2 )  invert swap invert swap ;                                                                             \ Shift                                                         : UD2/ ( xd1 -- xd2 )  d2/ [ 0 invert 1 rshift ] literal and ;  : DRSHIFT ( xd1 n -- xd2 )  0 ?do ud2/ loop ;                   : DLSHIFT ( xd1 n -- xd2 )  0 ?do d2* loop ;                                                                                    \ Mixed - MU* MU/MOD UT* UT/                                    \ Multiply double by single. Unsigned.                          : MU* ( ud1 u -- ud2 )                                            tuck * >r um* r> + ;                                                                                                          \ Divide double by single. Unsigned.                            : MU/MOD ( ud u -- urem udquot )                                  tuck 0 swap um/mod >r swap um/mod r> ;                                                                                        \ Multiply double by single leaving triple. Unsigned.           : UT* ( ud u -- ut )  dup rot 2>r um* 0 2r> um* d+ ;                                                                            \ Divide triple by single leaving double. Unsigned.             : UT/ ( ut u -- ud )                                              dup >r um/mod -rot r> um/mod nip swap ;                                                                                       \ Mixed - FDM/MOD SDM/                                          \ Divide signed double by positive single. Floored.             : FDM/MOD ( d +n -- rem dquot )                                   tuck >r s>d r> fm/mod >r swap um/mod r> ;                                                                                     \ Divide signed double by positive single. Symmetric.           : SDM/ ( d +n -- dquot )                                          fdm/mod rot over 0< and if 1 m+ then ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        \ 16-bit square root                                            : SQRT ( u -- rem root )  \ Wil Baden                             0 0  [ 4 cells ] literal 0 do                                     >r  d2* d2*  r>  2*                                             2dup 2* u> if                                                     dup >r  2* - 1-  r> 1+                                        then                                                          loop                                                            rot drop ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    \ 16-bit square root                                            : SQRT ( u1 -- u2 )  \ G.Jackson                                  dup 2 u< if end                                                 dup >r  u2/ u2/  recurse                                        2* 1+  dup  dup *  r> u>  + ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 \ 15-bit fast integer square root                               \ Returns root and remainder, or 0 -1 if n is negative  FD14/5  : SQRT ( +n -- root rem )                                         dup 0<  if  drop 0 -1  end                                      0 swap 16384 ( 2^14 )                                           begin                                                             >r  dup  2 pick  -  r@ -  dup 0<                                if    drop swap 2/                                              else  nip  swap 2/  r@ +  then                                  swap  r> 2/                                                     2/  dup 0=                                                    until  drop ;                                                                                                                                                                                                                                                                                                                 \ 31-bit fast integer square root                               \ Returns root and remainder, or 0 -1 if d is negative  FD14/5  : DSQRT ( +d -- droot drem )                                      dup 0<  if  2drop 0. -1.  end                                   0. 2swap 1073741824. ( 2^30 )                                   begin                                                             2>r  2dup  5 pick 5 pick  d-  2r@ d-  dup 0<                    if    2drop  2swap d2/                                          else  2nip  2swap d2/  2r@ d+  then                             2swap  2r> d2/                                                  d2/  2dup d0=                                                 until  2drop ;                                                                                                                                                                                                                                                                                                                \\ 31-bit integer square root                                   \ Returns root or -1 if d is negative  M.Barr                   code DSQRT ( +d -- u )                                            cx pop  bx pop  3 $ jcxz  cx dx mov  -1 # di mov              1 $: dx shl  2 $ jc  dx shl  2 $ jc  di shr  1 $ ju             2 $: cx dx mov  bx ax mov  di dx cmp  4 $ jnc  di div             di ax cmp  4 $ jnc  ax di add  di rcr  2 $ ju                 3 $: bx dx mov  $FF # di mov  bx bx or  1 $ jnz                   bx di mov  4 $: di push  next  end-code                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       \\ 30-bit integer square root                                   code DSQRT ( +d -- +n )                                           bx pop  dx pop  ax ax sub  di di sub  16 # cx mov             1 $:  dx shl  bx rcl  di rcl  dx shl  bx rcl  di rcl              ax shl  ax shl  ax inc  ax di cmp  2 $ jc  ax di sub            ax inc  2 $:  ax shr  1 $ loop  ax push  next  end-code                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       \ Simple random number generator                                \ LCS generator from 'Starting Forth'                                                                                           variable SEED  1 seed !                                                                                                         \ Get random number                                             : RAND ( -- u )  seed @  #31421 *  #6727 +  dup seed ! ;                                                                        \ Get random number between 0 and u-1                           : RANDOM ( u -- 0..u-1 )  rand um* nip ;                                                                                                                                                                                                                                                                                                                                                                                                                        \ Minimum standard random number generator                      \ LCS generator from Turbo-C                                                                                                    : D* ( d|ud1 d|ud2 -- d|ud3 )                                     rot 2>r 2dup um* rot r> * + rot r> * + ;                                                                                      2variable SEED  1. seed 2!                                                                                                      \ Get random number                                             : RAND ( -- u )                                                   seed 2@  #22695477. d*  1. d+  tuck  seed 2! ;                                                                                \ Get random number between 0 and u-1                           : RANDOM ( u -- 0..u-1 )  rand um* nip ;                                                                                                                                                        \ CRC-16                                                        \ x16+x15+x2+1  Initial CRC = 0                                                                                                 \ : CRC-16 ( crc byt -- crc' )                                  \  xor 8 0 do dup 1 and if u2/ $A001 xor else u2/ then loop ;                                                                   code CRC-16 ( crc byt -- crc' )                                   d pop  h pop  e a mov  l xra  a l mov  8 e mvi  1 $:            a ora  h a mov  rar  a h mov  l a mov  rar  a l mov             2 $ jnc  l a mov  $01 xri  a l mov  h a mov  $A0 xri            a h mov  2 $:  e dcr  1 $ jnz  1push  end-code                                                                                                                                                                                                                                                                                                                                                \ CRC-16 table-driven                                           \ x16+x15+x2+1  Initial CRC = 0                                 -? create tb  #256 2* allot                                                                                                     -? : !tb  #256 0 do i 8 0 do dup 1 and >r u2/ r> if $A001         xor then loop i 2* tb + ! loop ;  !tb forget  !tb                                                                             \ : CRC-16 ( crc 8b -- crc' )                                   \  over xor $FF and 2* tb + @ swap 8 rshift xor ;                                                                               code CRC-16  ( crc 8b -- crc' )                                   h pop  d pop  l a mov  e xra  a l mov  d a mov  h dad           tb d lxi  d dad  m xra  h inx  m h mov  a l mov  1push          end-code                                                                                                                      behead tb tb                                                    \ CRC-CCITT                                                     \ x16+x12+x5+1  Initial CRC = $1D0F                                                                                             \ : CRC-CCITT ( crc byt -- crc' )                               \  >< xor 8 0 do dup 0< if 2* $1021 xor else 2* then loop ;                                                                     code CRC-CCITT ( crc byt -- crc' )                                d pop  h pop  e a mov  h xra  a h mov  8 e mvi  1 $:            a ora  l a mov  ral  a l mov  h a mov  ral  a h mov             2 $ jnc  l a mov  $21 xri  a l mov  h a mov  $10 xri            a h mov  2 $:  e dcr  1 $ jnz  1push  end-code                                                                                                                                                                                                                                                                                                                                                \ CRC-CCITT table-driven                                        \ x16+x12+x5+1  Initial CRC = $1D0F                             -? create tb  #256 2* allot                                                                                                     -? : !tb  #256 0 do 0 i >< xor 8 0 do dup 0< if 2* $1021 xor      else 2* then loop i 2* tb + ! loop ;  !tb  forget !tb                                                                         \ : CRC-CCITT ( crc 8b -- crc' )                                \  over 8 rshift xor 2* tb + @ swap 8 lshift xor ;                                                                              code CRC-CCITT ( crc 8b -- crc' )                                 h pop  d pop  l a mov  d xra  a l mov  e a mov  h dad           tb d lxi  d dad  m e mov  h inx  m xra  a h mov  e l mov        1push  end-code                                                                                                               behead tb tb                                                    \ CRC-X25                                                       \ x16+x12+x5+1  Initial CRC = -1, INVERT final CRC                                                                              \ : CRC-X25 ( crc byt -- crc' )                                 \  xor 8 0 do dup 1 and if u2/ $8408 xor else u2/ then loop ;                                                                   code CRC-X25 ( crc byt -- crc' )                                  d pop  h pop  e a mov  l xra  a l mov  8 e mvi  1 $:            a ora  h a mov  rar  a h mov  l a mov  rar  a l mov             2 $ jnc  l a mov  $08 xri  a l mov  h a mov  $84 xri            a h mov  2 $:  e dcr  1 $ jnz  1push  end-code                                                                                                                                                                                                                                                                                                                                                \ CRC-X25 table-driven                                          \ x16+x12+x5+1  Initial CRC = -1, INVERT final CRC              -? create tb  #256 2* allot                                                                                                     -? : !tb  #256 0 do i 8 0 do dup 1 and >r u2/ r> if $8408         xor then loop i 2* tb + ! loop ;  !tb  forget !tb                                                                             \ : CRC-X25 ( crc 8b -- crc' )                                  \  over xor $FF and 2* tb + @ swap 8 rshift xor ;                                                                               code CRC-X25  ( crc 8b -- crc' )                                  h pop  d pop  l a mov  e xra  a l mov  d a mov  h dad           tb d lxi  d dad  m xra  h inx  m h mov  a l mov  1push          end-code                                                                                                                      behead tb tb                                                    \ CRC-XMODEM                                                    \ x16+x12+x5+1  Initial CRC = 0                                                                                                 \ : CRC-XMODEM ( crc byt -- crc' )                              \  >< xor 8 0 do dup 0< if 2* $1021 xor else 2* then loop ;                                                                     code CRC-XMODEM ( crc byt -- crc' )                               d pop  h pop  e a mov  h xra  a h mov  8 e mvi  1 $:            a ora  l a mov  ral  a l mov  h a mov  ral  a h mov             2 $ jnc  l a mov  $21 xri  a l mov  h a mov  $10 xri            a h mov  2 $:  e dcr  1 $ jnz  1push  end-code                                                                                                                                                                                                                                                                                                                                                \ CRC-XMODEM table-driven                                       \ x16+x12+x5+1  Initial CRC = 0                                 -? create tb  #256 2* allot                                                                                                     -? : !tb  #256 0 do 0 i >< xor 8 0 do dup 0< if 2* $1021 xor      else 2* then loop i 2* tb + ! loop ;  !tb  forget !tb                                                                         \ : CRC-XMODEM ( crc 8b -- crc' )                               \  over 8 rshift xor 2* tb + @ swap 8 lshift xor ;                                                                              code CRC-XMODEM ( crc 8b -- crc' )                                h pop  d pop  l a mov  d xra  a l mov  e a mov  h dad           tb d lxi  d dad  m e mov  h inx  m xra  a h mov  e l mov        1push  end-code                                                                                                               behead tb tb                                                    \ CRC-32                                                        \ CCITT  Initial CRC = -1, DINVERT final CRC                                                                                    : CRC-32 ( dcrc byt -- dcrc' )                                    8 0 do -rot over 3 pick xor 1 and >r ud2/ r> if                 $EDB8 xor swap $8320 xor swap then rot 1 rshift loop drop ;                                                                   \ code CRC-32 ( dcrc byt -- dcrc' )                             \  bx pop  ax pop  dx pop  8 # cx mov  1 $: bl bh mov  dl bh xor\  ax 1 shr  dx 1 rcr  bh 1 shr  2 $ jnc  $EDB8 # ax xor        \  $8320 # dx xor  2 $: bl 1 shr  1 $ loop  2push  end-code                                                                     : DINVERT ( d1 -- d2 )  invert swap invert swap ;                                                                                                                                                                                                               \ CRC-32 table-driven                                           \ CCITT  Initial CRC = -1, DINVERT final CRC                    -? create tb  #256 2* 2* allot                                  -? : !tb  #256 0 do i 0 8 0 do over 1 and >r ud2/                 r> if $EDB8 xor swap $8320 xor swap then loop i 2* 2*           tb + 2! loop ;  !tb  forget !tb                                                                                               : CRC-32 ( dcrc 8b -- dcrc' )                                     2 pick xor $FF and 2* 2* tb + 2@ 2>r 8 0 do                     d2/ loop $FF and r> xor swap r> xor swap ;                                                                                    \ code CRC-32  ( dcrc 8b -- dcrc' )                             \  bx pop  ax pop  dx pop  dl bl xor  bx bx add  bx bx add      \  tb # bx add  dh dl mov  al dh mov  ah al mov  ah ah sub      \  0 [bx] ax xor  2 [bx] dx xor  2push  end-code                behead tb tb  : DINVERT ( d1 -- d2 )  invert swap invert swap ; \ Sieve BYTE benchmark                                          8190 constant SIZE  create FLAGS  size allot                                                                                    : PRIME ( -- )                                                    flags size 1 fill                                               0 size 0 do                                                       flags i + c@ if                                                   i dup + 3 + dup i +                                             begin dup size <                                                while 0 over flags + c! over +                                  repeat drop drop 1+                                           then                                                          loop cr . ." Primes " ;                                                                                                       : SIEVE ( -- )  cr 10 0 do prime loop ;                                                                                         \ Interface Age benchmark                                       : BENCH ( 1000 -- )                                               dup 2 / 1+ swap cr ." Starting " CR                             1 do dup i 1 rot                                                  2 do drop dup i /mod                                              dup 0= if drop drop 1 leave                                       else 1 = if drop 1                                                else dup 0 > if drop 1                                            else 0= if 0 leave then                                         then                                                          then                                                          then                                                          loop                                                          if 4 .r else drop then                                          loop                                                          drop cr ." Finished. " ;                                      \ PARSE-NAME                                                    sys @  system                                                                                                                   : PARSE-NAME ( -- c-addr u )                                      bl true [ ' parse 4 + ] literal execute ;                                                                                     sys !                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \ ARRAY multi-dimension array                                   -? : ARRAY ( dimn..dim1 n itemsize "name" )                       create                                                            >r dup c, 1 swap 0 do over , * loop r> dup , * allot          does> ( idxn..idx1 -- addr )                                      count 0 tuck do >r cell+ dup @ rot r> + * loop + cell+ ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    \ ARRAY multi-dimension array                                   sys @  application                                              here  [asm ready  ( idxn..idx1 -- addr )                          c l mov  b h mov  2 $ shld  b pop  b ldax  b inx  0 h lxi     1 $:  d pop  d dad  psw push  b inx  b inx  b ldax  a e mov       b inx  b ldax  a d mov  b dcx  mulx call  xchg  psw pop         a dcr  1 $ jnz  b inx  b inx  b dad  h push  2 $ lhld           l c mov  h b mov  next  2 $:  0 ,                             check asm]  ( xt)                                                                                                               system  checking off                                            : ARRAY                                                           ( xt) literal  build ( dimn..dim1 n itemsize "name" )           >r dup c, 1 swap 0 do over , * loop r> dup , * allot ;        checking on  sys !                                                                                                              \ F2DUP FTUCK FNIP FCEIL FTRUNC FMOD                            : F2DUP ( r1 r2 -- r1 r2 r1 r2 )  fover fover ;                 : FTUCK ( r1 r2 -- r2 r1 r2 )  fswap fover ;                    : FNIP ( r1 r2 -- r2 )  fswap fdrop ;                                                                                           : FCEIL ( r1 -- r2 )  fnegate floor fnegate ;                   : FTRUNC ( r1 -- r2 )  fdup f0< if fceil end  floor ;                                                                           : FMOD ( r1 r2 -- r3 )  f2dup f/ ftrunc f* f- ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 \ FATAN2                                                        : FATAN2 ( y x -- r )                                             fdup f0< >r                                                     fdup f0= if                                                       fswap f< if                                                       [ pi  0.5e f* ] fliteral                                      else                                                              [ pi -0.5e f* ] fliteral                                      then                                                          else  f/ fatan  then                                            r> if                                                             pi fover f0> if  f-  end  f+                                  then ;                                                                                                                                                                                                                                                        \ +FIELD                                                        \ Define a field within a data structure                        -? : +FIELD                                                       create ( offs1 size "name" -- offs2 )  over , +                 does> ( a1 -- a2 )  @ + ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \ +FIELD                                                        \ Define a field within a data structure                        sys @  application                                              here  [asm ( a1 -- a2 )  h pop ( pfa)                             d pop  m a mov  e add  a e mov  h inx                           m a mov  d adc  a d mov  d push  next                         asm]  ( xt)                                                                                                                     system  checking off                                            : +FIELD ( offs1 size "name" -- offs2 )                           ( xt) literal  build over , + ;                               checking on  sys !                                                                                                                                                                                                                                                                                                              \ +TO                                                           sys @  system                                                                                                                   : +TO ( n "name" -- )                                             >in @ >r  '  state @ if  compile,  postpone +                   else  execute  +  then  r> >in !  postpone to ; immediate                                                                     sys !                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \ FVALUE FTO                                                    sys @  system                                                                                                                   aka fconstant FVALUE                                                                                                            : FTO ( r "name" -- )  [compile] addr                             state @ if  compile  then  f! ; immediate                                                                                     sys !                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \ 2VALUE 2TO                                                    sys @  system                                                                                                                   aka 2constant 2VALUE                                                                                                            : 2TO ( x1 x2 "name" -- )  [compile] addr                         state @ if  compile  then  2! ; immediate                                                                                     sys !                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \ C@+ C!+ @+ !+                                                 : C@+ ( a1 -- a2 c )  dup char+ swap c@ ;                       : C!+ ( a1 c -- a2 )  over c! char+ ;                                                                                           : @+ ( a1 -- a2 n )  dup cell+ swap @ ;                         : !+ ( a1 n -- a2 )  over ! cell+ ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             \ C@+ C!+ @+ !+                                                 code C@+ ( a1 -- a2 c )                                           h pop  m e mov  0 d mvi  h inx  xchg  2push                   end-code                                                                                                                        code C!+ ( a1 c -- a2 )                                           d pop  h pop  e m mov  h inx  1push                           end-code                                                                                                                        code @+ ( a1 -- a2 n )                                            h pop  m e mov  h inx  m d mov  h inx  xchg  2push            end-code                                                                                                                        code !+ ( a1 n -- a2 )                                            d pop  h pop  e m mov  h inx  d m mov  h inx  1push           end-code                                                        \ F@+                                                           \ : F@+ ( a1 -- a2 r )                                          \  dup [ 1 floats ] literal + swap f@ ;                                                                                         code F@+ ( a1 -- a2 r )                                           d pop  1 floats h lxi  d dad  h push  d push  ' f@ jmp        end-code                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        \ 1+! 1-! C@+ C!+ -C@ -C!                                       \ pointer operations on a VARIABLE                              : 1+! ( a -- )  1 swap +! ;                                     : 1-! ( a -- )  -1 swap +! ;                                    \ post-incrementing                                             : C@+ ( a -- c )  dup @ c@ swap 1+! ;                           : C!+ ( c a -- )  tuck @ c! 1+! ;                               \ pre-decrementing                                              : -C@ ( a -- c )  dup 1-! @ c@ ;                                : -C! ( c a -- )  dup 1-! @ c! ;                                                                                                                                                                                                                                                                                                                                                                                                                                \ 1+! 1-! C@+ C!+ -C@ -C!                                       \ pointer operations on a VARIABLE                              code 1+! ( a -- )  h pop  m e mov  h inx  m d mov  d inx          d m mov  h dcx  e m mov  next  end-code                       code 1-! ( a -- )  h pop  m e mov  h inx  m d mov  d dcx          d m mov  h dcx  e m mov  next  end-code                       \ post-incrementing                                             code C@+ ( a -- c )  h pop  m e mov  h inx  m d mov  d push       d inx  d m mov  h dcx  e m mov  ' c@ jmp  end-code            code C!+ ( c a -- )  h pop  m e mov  h inx  m d mov  d push       d inx  d m mov  h dcx  e m mov  ' c! jmp  end-code            \ pre-decrementing                                              code -C@ ( a -- c )  h pop  m e mov  h inx  m d mov  d dcx        d push  d m mov  h dcx  e m mov  ' c@ jmp  end-code           code -C! ( c a -- )  h pop  m e mov  h inx  m d mov  d dcx        d push  d m mov  h dcx  e m mov  ' c! jmp  end-code           \ R-ALLOT                                                       \ Allot u bytes on return stack. R@ gives buffer address.       \ RDROP this item before exiting definition.                    code R-ALLOT ( u -- )                                             d pop  d inx  e a mov  $FE ani ( make even )  a e mov           b push  rpp lhld  h b mov  l c mov  dsub call                   h push  h dcx  b m mov  h dcx  c m mov  1 $ d lxi               h dcx  d m mov  h dcx  e m mov  d pop  h dcx  d m mov           h dcx  e m mov  rpp shld  b pop  next                           \ remove buffer on exit                                       1 $:  here cell+ ,  rpp lhld  m e mov  h inx  m d mov  xchg       rpp shld  ' exit jmp  end-code                                                                                                                                                                                                                                                                                                \ Z80 16-bit multiply/divide subroutine                         label MUL16  \ Multiply  HL <- HL*DE                              b push  h b mov  l c mov  0 h lxi  #16 a mvi                    1 $:  b srlr  c rarr  2 $ jnc  d dad  2 $:                      e slar  d ralr  a dcr  1 $ jnz  b pop  ret                    end-code                                                                                                                        label DIV16  \ Divide  HL <- HL/DE  DE <- rem                     b push  h b mov  l c mov  0 h lxi  #16 a mvi                    1 $:  c ralr  b ralr  h dadc  d dsbc  2 $ jnc                   d dad  2 $:  cmc  a dcr  1 $ jnz  c ralr                        b ralr  b d mov  c e mov  xchg  b pop  ret                    end-code                                                                                                                                                                                                                                                        \ 8080 16-bit multiply/divide subroutine                        label MUL16  \ Multiply  HL <- HL*DE                              b push  d b mov  e c mov  0 d lxi  1 $:  a ora  b a mov         rar  a b mov  c a mov  rar  a c mov  2 $ jnc  xchg  d dad       xchg  2 $:  h dad  b a mov  c ora  1 $ jnz  b pop  ret        end-code                                                                                                                        label DIV16  \ Divide  HL <- HL/DE  DE <- rem                     e a mov  d ora  rz  b push  a xra  xchg  1 $:  a inr  h dad     1 $ jnc  xchg  e c mov  d b mov  0 d lxi  2 $:  psw push        b a mov  rar  a b mov  c a mov  rar  a c mov  stc  e a mov      ral  a e mov  d a mov  ral  a d mov  l a mov  c sbb             a l mov  h a mov  b sbb  a h mov  3 $ jnc  b dad  e dcr         3 $:  psw pop  a ora  a dcr  2 $ jnz  xchg  b pop  ret        end-code                                                                                                                        \ Euclidean division                                            \ Returns positive remainder irrespective of input sign         \ Ref: 'divmodnote.pdf' D.Leijen                                : E/MOD ( dividend divisor -- rem quot )                          dup >r /mod over 0< if                                            r@ 0> if                                                          1- swap r@ + swap                                             else                                                              1+ swap r@ - swap                                             then                                                          then  rdrop ;                                                                                                                 \\ Portable version                                             : E/MOD ( dividend divisor -- rem quot )                          >r s>d r@ sm/rem over 0< if ...                                                                                               \ ANEW                                                          sys @  system                                                   \ Forget marker if it exists then create new                    : ANEW ( "name" )                                                 >in @  postpone [defined]  if  dup >in !  forget  then          >in !  marker ;                                               sys !                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \ SEAL                                                          sys @  system                                                   \ Remove FORTH from search order leaving CONTEXT and CURRENT    : SEAL ( -- )  context 2 cells + off ;                          sys !                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \ +USER                                                         sys @  system                                                   \ Create USER variable reserving u bytes                        : +USER ( offs1 u "name" -- offs2 )  bounds user ;              sys !                                                                                                                           \\ usage                                                        #user                                                           1 cells +user USERVAR                                           to #user                                                                                                                                                                                                                                                                                                                                                                                                                                                        \ SET-BIT CLR-BIT XOR-BIT TST-BIT                               code SET-BIT ( mask c-addr -- )                                   h pop  d pop  m a mov  e ora  a m mov  next  end-code                                                                         code CLR-BIT ( mask c-addr -- )                                   h pop  d pop  e a mov  cma  m ana  a m mov  next  end-code                                                                    code XOR-BIT ( mask c-addr -- )                                   h pop  d pop  m a mov  e xra  a m mov  next  end-code                                                                         code TST-BIT ( mask c-addr -- flag )                              h pop  d pop  m a mov  e ana  ' false jz                        ' true jmp  end-code                                                                                                                                                                                                                                          \ Quotations                                                    \ Load before locals to give quotations access to parent locals system                                                          : [: ( c: -- q-sys )                                              state @ if                                                        last 2@  postpone ahead  bal @  csp @  true                   else  false  then  :noname  ; immediate                                                                                       : ;] ( c: q-sys -- ; -- | xt )                                    postpone ;  >r  if                                                csp !  bal !  ]  postpone then  last 2!                         r>  postpone literal                                          end  r> ( xt ) ; immediate                                    application                                                                                                                                                                                     \ DO LOOP extensions                                            \ Get address of item immediately above DO LOOP parameters      code 'R ( -- addr )                                               rpp lhld  2 cells d lxi  d dad  1push                         end-code                                                                                                                        \ Copy DO LOOP limit                                            code I' ( -- x )                                                  rpp lhld  h inx  0 d lxi  ' I 6 + jmp  end-code                                                                               \ Copy of n'th loop index  0 = I, 1 = J etc                     code ITH ( n -- index )                                           h pop  h dad  h dad  xchg  rpp lhld  ' I 3 + jmp  end-code                                                                                                                                                                                                    \ SYNONYM                                                       sys @  system                                                   : SYNONYM ( "newname" "oldname" )                                 <#  token shold  token 1+ shold  s" AKA " shold  0 0 #>         evaluate ;                                                    sys !                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \ FEED                                                          \ Feed string a u to parsing word xt                            sys @  system                                                   : FEED ( a u xt -- )                                              -rot s" EXECUTE " >pad +string evaluate ;                     sys !                                                                                                                           \\                                                              s" FOOBAR" ' CREATE feed                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        \ MJD - Modified Julian Date                                    \ MJD is number of days since 1899-12-31 stored as 16-bit       \ unsigned number. Valid range is 1900-3-1 to 2079-6-5.         \ Modulo seven of MJD number returns day-of-week.               -? #365 4 * 1 + constant d/y                                    -? create days  -1 , 0 , #31 , #59 , #90 , #120 , #151 ,          #181 , #212 , #243 , #273 , #304 , #334 , #367 ,              -? : @mth ( u1 -- u2 )  cells days + @ ;                                                                                        : >MJD ( d m y -- mjd )  #1900 - >r @mth #58 over < if r@         3 and 0= - then + 1- r> d/y um* 4 um/mod swap 0<> - + ;                                                                       : MJD> ( mjd -- d m y )  4 um* d/y um/mod #1900 + swap 4 /mod     1+ dup rot 0= if dup #60 > + swap dup #59 > + then 1 begin      1+ 2dup @mth > 0= until 1- nip tuck @mth - swap rot ;         behead d/y @mth                                                 \ ZCOUNT ZPLACE ZAPPEND                                         \ Get addr/len of z-string                                      : ZCOUNT ( c-addr -- c-addr2 u2 )  -1 2dup 0 scan nip - ;                                                                       \ Store string as z-string                                      : ZPLACE ( c-addr u c-addr2 -- )  zcount +string + 0 swap c! ;                                                                  \ Z-string append                                               : ZAPPEND ( c-addr u c-addr2 -- )  zcount + zplace ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                            \ CVARIABLE C+!                                                 sys @ system                                                    : CVARIABLE ( "name" ; c-addr )  create  1 allot ;                                                                              application                                                     \ : C+! ( n c-addr -- )  tuck c@ + swap c! ;                                                                                    code C+! ( n c-addr -- )                                          h pop  d pop  m a mov  e add  a m mov  next  end-code                                                                         sys !                                                                                                                                                                                                                                                                                                                                                                                           \ C"                                                            \ Compile quote delimited string 255 chars max. At run-time     \ return address of counted string.                                                                                             application                                                     [asm  here ( xt)                                                b push  b ldax  a l mov  0 h mvi  b inx  b dad                  l c mov  h b mov  next                                          asm]                                                                                                                            system  checking off                                            : C" ( -- c-addr )                                                compile  [ ( xt) compile, ]  ," ; immediate                   checking on  application                                                                                                                                                                        \ SHUFFLE                                                       \ Shuffle characters within an array. For cells change          \ CHARS C@ C! CHAR+ to CELLS @ ! CELL+ etc.                                                                                     : SHUFFLE ( adr len -- )                                          begin dup while >r                                                dup r@ random chars +                                           2dup c@  swap c@                                                rot  c!  over c!                                                char+  r> 1-                                                  repeat 2drop ;                                                                                                                                                                                                                                                                                                                                                                                \ Quicksort                                                     \ Quicksort chars (adapted from Wil Baden)                      defer PRECEDES ( c1 c2 -- f )  \ comparison                                                                                     -? : q ( lo hi -- )  2dup  over -  u2/                            [ -1 chars ] literal  and  + c@ >r  2dup swap  begin              begin dup c@  r@ precedes while 1+ repeat swap                  begin r@ over c@ precedes while 1- repeat swap                  2dup u< not if  over c@ over c@  3 pick c!  over c!               swap 1-  swap 1+  then  2dup u<                             until  rdrop  rot  2over 2over - + > if 2swap then              2dup u< if recurse else 2drop then                              2dup u< if recurse end  2drop ;                                                                                               : SORT ( adr siz -- )                                             dup if  1- chars over + q  end  2drop ;  behead q q           \ Bubblesort                                                    \ Bubblesort addr/cells                                         defer PRECEDES ( x1 x2 -- f )  \ comparison                                                                                     : SORT ( adr siz -- )                                             begin dup while 1-                                                2dup cells bounds ?do                                             i 2@ precedes if  i 2@ swap i 2!  then                        1 cells +loop                                                 repeat 2drop ;                                                                                                                                                                                                                                                                                                                                                                                                                                                \ Combsort                                                      \ Combsort addr/cells                                           defer PRECEDES ( x1 x2 -- f )  \ comparison                                                                                     -? integer g  -? variable s  \ gap & flag                                                                                       : SORT ( adr siz -- )                                             dup if  dup to g  begin                                           g  93 116 */  1 max  to g  s on                                 2dup  g - cells  bounds ?do                                       i g cells + @  i @  precedes if                                   i g cells +  i                                                  2dup @  swap @  rot !  swap !  s off                          then                                                          1 cells +loop  s @  g 1 =  and                                until  then  2drop ;   behead g s                             \ Circlesort                                                    \ Circlesort addr/cells  H.Bezemer                              defer PRECEDES ( x1 x2 -- f )  \ comparison                                                                                     -? variable s                                                                                                                   -? : c ( a1 a2 -- )  2dup = if 2drop end                          2dup swap  begin  2dup u> while                                   over @  over @  precedes if                                       over @ over @  3 pick !  over !  s off                        then  swap cell-  swap cell+                                  repeat  rot  2over 2over - + > if 2swap then                    recurse  recurse ;                                                                                                            : SORT ( adr siz -- )  dup if  1- cells  over +                   begin  s on  2dup c  s @ until  then  2drop ;  behead s c     \ LOCASE LOWER                                                  label LWC  char A cpi  rc  char Z 1+ cpi  rnc  $20 xri  ret     end-code                                                                                                                        code LOCASE ( c1 -- c2 )                                          h pop  l a mov  lwc call  1push  end-code                                                                                     code LOWER ( adr len -- )                                         d pop  h pop  1 $:  d a mov  e ora  'next jz                    m a mov  lwc call  a m mov  h inx  d dcx  1 $ jmp             end-code                                                                                                                        behead lwc lwc                                                                                                                                                                                                                                                  \ LOG2                                                          \ LOG base 2                                                    : LOG2 ( u1 -- u2 )  \ Rick C.                                    0 begin swap u2/ dup while swap 1+ repeat drop ;                                                                              \\                                                              code LOG2 ( u1 -- u2 )                                            d pop  a xra  a l mov  a h mov  1 $:  d a mov  rar  a d mov     e a mov  rar  a e mov  d ora  hpush jz  h inx  1 $ jmp        end-code                                                                                                                                                                                                                                                                                                                                                                                                                                                        \ /ALLOT /RESERVE                                               \ Versions that clear the data space                                                                                            : /ALLOT ( u -- )  dup reserve swap erase ;                                                                                     : /RESERVE ( u -- addr )  here swap /allot ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    \ DOER/MAKE                                                     \ ref: 'Thinking FORTH'                                         application                                                     -? code m  b ldax  a e mov  b inx  b ldax  a d mov  b inx         b ldax  a l mov  b inx  b ldax  a h mov  b inx  c m mov         h inx  b m mov  e c mov  d b mov  next  end-code              -? create e  ' exit ,  :noname  @ >r ;  system  -? integer h    ( xt) to h  : DOER  [ h ] literal build e , ;                   : MAKE  ' >body  state @ if  postpone m  here to h  e ,  ,  end   :noname  >body  swap !  !csp  ] ; immediate                   : ;AND  postpone exit  here h ! ; immediate                     : UNDO  e  ' >body ! ;                                          application  behead m h                                                                                                         \ doer BAR  : FOO bar ;  : TEST make bar ." hello" ;and foo ;   \ undo BAR                                                      \ N/Y                                                           \ As for Y/N but default is 'Y'                                 : N/Y ( -- flag )  ." Y\08"                                       key upcase  [char] N = invert  dup .yn ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      \ FLOAT?                                                        \ As for >FLOAT but treat blank/empty string as error           : FLOAT? ( adr len -- r -1 | 0 )                                  2dup -trailing nip if >float end  2drop 0 ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   \ M,                                                            \ Compile memory                                                : M, ( adr len -- )  dup reserve swap move ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    \ ]] [[                                                         \ POSTPONE macro                                                sys @ system                                                    : ]]                                                              begin  >in @  token ?dup                                        while  s" [[" compare                                           while  >in !  [compile] postpone                                repeat drop end  2drop ; immediate                            sys !                                                                                                                           \\ Example                                                      system                                                          : OF  ]] over = if drop [[ ; immediate                          application                                                                                                                                                                                     \\ TIME&DATE                                                    : @TIME ( -- sec min hour )                                       $2C doscall  'DH c@  'CX c@  'CH c@ ;                                                                                         : @DATE ( -- day mon year )                                       $2A doscall  'DX c@  'DH c@  'CX @ ;                                                                                          : TIME&DATE ( -- sec min hour day mon year )                      begin  @date 2drop >r  @time @date  2 pick r> -                 while  2drop 2drop 2drop  repeat ;                                                                                                                                                                                                                                                                                                                                                                                                                            \ CPMEOF /EOL GETLN                                             variable CPMEOF  cpmeof off  \ CP/M EOF received                                                                                code /EOL ( a u -- u' offs )  \ scan for CR LF CRLF               d pop  c l mov  b h mov  xthl  h push  0 b lxi  1 $:  e a mov   d ora  4 $ jz  m a mov  $0D cpi  2 $ jz  $0A cpi  3 $ jz        $1A cpi  5 $ jz  h inx  d dcx  1 $ jmp  5 $:  -1 d lxi  xchg    cpmeof shld  xchg  4 $ jmp  2 $:  b inx  h inx  m a mov         h dcx  $0A cpi  4 $ jnz  3 $:  b inx  4 $:  d pop  dsub call    c e mov  b d mov  b pop  h push  d dad  1push  end-code                                                                       : GETLN ( a u -- a u2 EOL -1 | 0 )  \ needs DOSLIB                inpos 2>r  tuck read  rot 1- umin  dup if  cpmeof off           2dup /eol  0  2r>  cpmeof @ if  2drop  2swap nip dup 2swap      ifid fsize  then  d+ seekin  tuck  <>  -1  end                  rdrop rdrop nip ;                                             \ SUBST                                                         \ Replace all occurrences                                       ' count build "FND ( -- a u )  0 c, 63 allot                    ' count build "REP ( -- a u )  0 c, 63 allot                                                                                    : SUBST ( a u a2 -- a2 u2 )                                       0  2>r  begin  2dup "fnd search  while                            2swap  2 pick -  2r> +string                                    "rep 2swap +string  2>r  "fnd nip /string                     repeat  2drop  2r> +string ;                                                                                                  \\                                                              s" foo" addr "fnd place                                         s" bar" addr "rep place                                         s" foo bar foo" pad subst  cr type                                                                                              \ REPLACE                                                       \ Replace first occurrence only                                 ' count build "FND ( -- a u )  0 c, 63 allot                    ' count build "REP ( -- a u )  0 c, 63 allot                                                                                    : REPLACE ( a u a2 -- a2 u2 )                                     0  2>r  2dup "fnd search  if                                      2swap  2 pick -  2r> +string                                    "rep 2swap +string  2>r  "fnd nip /string                     else  2drop  then  2r> +string ;                                                                                              \\                                                              s" foo" addr "fnd place                                         s" bar" addr "rep place                                         s" foo bar foo" pad replace  cr type                                                                                            \ (F.R)                                                         \ Convert r to string right-justified in field wid with prec    \ significant digits in fixed-point format. If not fit, try     \ scientific and optionally if that fails display asterisk.     : (F.R) ( r prec wid -- a u )                                     >r  set-precision  fdup -1 (f.)  dup r@ > if                      2drop  -1 (fs.)                                             \    dup r@ > if <#  r> [char] * nhold  #>  end                   else  2>r fdrop 2r>  then                                       r> over - 0 max bl nhold  #> ;                                                                                                                                                                                                                                                                                                                                                                                                                                \ PERMUTE Heap's algorithm                                      \ Generate all permutations of u objects in a table             defer XCHG ( i1 i2 -- )  \ exchange objects                     defer RUN-PERM ( -- )  \ use current permutation                                                                                : PERMUTE ( u -- )  \ G.Jackson                                   1- dup if                                                         dup 0 do                                                          dup recurse                                                     dup 1 and negate i and over xchg                              loop  recurse                                                 end  drop run-perm ;                                          \\                                                              :noname ( i1 i2 -- )  cells tbl + swap cells tbl +                over @ over @ swap rot ! swap ! ; is xchg                                                                                     \ GOTO                                                          \ based on version by Minforth                                  forth definitions decimal  system  warning off                  6  constant #l  \ labels (10 max)                               10 constant #f  \ forward references                                                                                            create l  #l cells allot                                        create f  #f 2* cells allot                                     : >l ( # -- a )  cells l + ;                                    : >f ( # -- a )  2* cells f + ;                                 : /# ( "#" -- # )  char  #l >digit 0= abort" bad label" ;       warning on                                                                                                                      : L#: ( "#" -- )  \ declare label                                 here  /# >l  dup @ abort" dup label"  ! ; immediate           -->                                                             \ GOTO cont'd                                                   : GOTO ( "#" -- )  \ jump to label                                /#  dup >l @  0 of ( fwd ref)  here 2dup swap                     [ #f 1- ] literal >f @ invert abort" GOTO full"                 f  dup 1 >f [ #f 1- 2* cells ] literal move  2!               then  postpone again  1 bal +!  drop ; immediate                                                                              : +LBL ( -- )  \ ** execute before using labels                   l [ #l cells ] literal erase                                    f [ #f 2* cells ] literal -1 fill ; immediate                                                                                 : -LBL ( -- )  \ ** execute after using labels                    #f 0 do  i >f 2@  -1 of drop break  >l @                        dup 0= abort" need label"  swap cell+ !  loop ; immediate                                                                     behead #l /#  application                                       \ F>R FR>                                                       code F>R ( r -- )                                                 rpp lhld  -1 floats d lxi  d dad  rpp shld                      h push  ' f! jmp                                              end-code                                                                                                                        code FR> ( -- r )                                                 rpp lhld  h push  c: f@ ;c  rpp lhld                            1 floats d lxi  d dad  rpp shld  next                         end-code                                                                                                                                                                                                                                                                                                                                                                                                                                                        \ (ENG.)                                                        -? create si                                                      char z c,  char y c,  char a c,  char f c,  char p c,           char n c,  char u c,  char m c,      bl c,  char k c,           char M c,  char G c,  char T c,  char P c,                    \ Convert r to string in engineering notation with SI suffix    : (ENG.) ( r prec -- adr len )                                    precision  fdp @  2>r  \ save defaults                          fdp off  ( prec) set-precision  -1 (fe.) ( a u)                 2r>  fdp !  set-precision  \ restore defaults                   2dup [char] E scan ( a u a2 u2) dup if ( not NAN/INF)             2dup  1 /string ( skip 'E')  >int  #24 + 3 /                    dup 0 #14 within if \ SI range                                    si + c@ -rot  over swap blank  1+ c!  -trailing               end  drop                                                     then  2drop ;  behead si si                                   \ FLOG FLOG2                                                    \ Log base 10                                                   : FLOG ( r1 -- r2 )  fln 0.434294481903251828e f* ;                                                                             \ Log base 2                                                    : FLOG2 ( r1 -- r2 )  fln 1.44269504088896341e f* ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             