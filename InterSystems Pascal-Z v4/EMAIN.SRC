; Pascal/Z run-time support interface			 .
; COPYRIGHT 1978, 1979, 1980, 1981 BY JEFF MOSKOW
;
; This is a collection of macros for use in constructing
; external modules from Pascal routines
;
	NAME	EXTERN
	EXT	.FLTERR,.HPERR,.REFERR,.STKERR,.RNGERR,.DIVERR,.MLTERR
	EXT	.PERROR,.STMTMSG,.CRLF,.STRERR,.FPNEG
	EXT	.ILDV,.ILDV1,.ILDV2,.ILD1,.ILD11,.ILD12,.ILD2,.ILD21
	EXT	.ILD22
	EXT	.ISTR,.ISTR1,.ISTR2,.XADDR,.YADDR,.FSUB,.FADD,.ENTRSC
	EXT	.ENTER,.EXITF
	EXT	.FPEQ,.SEQUL,.FPNEQ,.SNE,.FPLTE,.SLE,.ILE,.FPLT,.SLT,.ILT
	EXT	.FPGTE,.SGE,.IGE,.FPGT,.SGT,.IGT,.FMULT,.IMULT,.QMULT,.IDIVD
	EXT	.IMOD,.NCDVD,.NCMOD
	EXT	.ERROR,.CSTS,.CI,.CO,.CHKDE,.CHKHL,.PSTAT,.CONSET,.UNION,.INN
	EXT	.LTEQ,.RCSET
	EXT	.GTEQ,.INSECT,.ORGAN,.COMP,.FUSS,.FOUT,.FXDCVT,.CVTFLT,.TOUT
	EXT	.TXTYP
	EXT	.FDIVD,.STREQL,.STRNQL,.STRLEQ,.STRLSS,.STRGEQ,.STRGRT,.LAST
	EXT	.WRTEL,L109,L110,L111,L112,L115,L116,L117,L118,L120
	EXT	.READLN,L121,L122,L123,L124,L125,L126,L127,L128,L129
	EXT	.WRITE,L130,L131,L132,L133,L134,L135,L136,L0
	EXT	.READ,L137,.OVERLAY,L138,L98
	EXT	.ABS
	EXT	.FPABS
	EXT	.SQR
	EXT	.FPSQR
	EXT	.EOLN
	EXT	.EOF
	EXT	.RESET
	EXT	.REWRITE
	EXT	.FTXTIN
	EXT	.CHAIN
	EXT	.NEW
	EXT	.MARK
	EXT	.RELEASE
	EXT	.TRUNC
	EXT	.ROUND
	EXT	.ARCTAN
	EXT	.COS
	EXT	.EXPFCT
	EXT	.LN
	EXT	.SQRT
	EXT	.SIN
R:	SET	0FFFFH
C:	SET	0FFFFH
M:	SET	0FFFFH
A:	SET	00000H
S:	SET	0FFFFH
D:	SET	0FFFFH
E:	SET	00000H
F:	SET	0FFFFH
T:	SET	00000H
VALID:	SET	00000H
CR	EQU	13
LF	EQU	10
EOFMRK	EQU	1AH
BUFLEN	EQU	80
MARGIN	EQU	50
COMPILER EQU	0H
MAXDRV	EQU	16
CPM	EQU	5
FINI:	MACRO
	ENDMAC
EXTR:	macro	intn,extn
extn:	equ	intn
	entry	extn
	endmac
EXTD:	MACRO	INTN,EXTN
	EXT	EXTN
INTN:	equ	EXTN
	ENDMAC
SPSH:	MACRO	Q,SIZE
	IF	SIZE
	IF	SIZE&8000H
	LXI	H,SIZE
	DAD	S
	SPHL
	ELSE
	MVI	A,SIZE
	CMP	M
	JC	.STRERR
	MOV	B,A
	INR	B
PSHLP:	SET	$
	MOV	D,M
	PUSH	D
	INX	S
	DCX	H
	DJNZ	PSHLP
	XRA	A
	ENDIF
	ENDIF
	ENDMAC
MLOAD:	MACRO	WHERE,VALUE
	IF	VALUE
	IF	VALUE&0FF00H
	LXI	B,VALUE
	CALL	WHERE!2
	ELSE
	MVI	C,VALUE
	CALL	WHERE!1
	ENDIF
	ELSE
	CALL	WHERE
	ENDIF
	ENDMAC
ILOD:	MACRO	Q,SIZE,OFST
	IF	SIZE&8000H
	MLOAD	.ILDV,OFST
	ELSE
	IF	SIZE-1
	MLOAD	.ILD2,OFST
	ELSE
	MLOAD	.ILD1,OFST
	ENDIF
	ENDIF
	ENDMAC
ISTR:	MACRO	Q,SIZE,OFST
	MLOAD	.ISTR,OFST
	IF	R
	JC	.REFERR
	ENDIF
	ENDMAC
LPOP:	MACRO	REG,DISTANCE
	IF	DISTANCE
	PUSH	H
	LXI	H,DISTANCE+2
	DAD	S
	MOV	E,M
	INX	H
	MOV	D,M
	PUSH	D
	MOV	D,H
	MOV	E,L
	DCX	H
	DCX	H
	LXI	B,DISTANCE
	LDDR
	POP	D
	POP	H
	POP	B
	ELSE
	POP	D
	ENDIF
	ENDMAC
LPUSH:	MACRO	REG,SIZE
	IF	SIZE-2 
	PUSH	REG
	LXI	H,0
	DAD	S
	XCHG
	LXI	H,-2
	DAD	S	
	SPHL
	XCHG
	LXI	B,SIZE+2
	LDIR
	POP	D
	LXI	H,SIZE
	DAD	S
	MOV	M,E
	INX	H
	MOV	M,D
	ELSE
	IF	'REG'-'H'
	XCHG
	ENDIF
	XTHL
	PUSH	H
	ENDIF
	ENDMAC
ADDR:	MACRO	Q
TEMP	SET	'Q'-'IY'
	IF	'Q'-'Y'*TEMP
	CALL	.XADDR
	ELSE
	CALL	.YADDR
	ENDIF
	ENDMAC
MIDL:	MACRO	REG,LEVEL
	PUSH	X
	MVI	A,LEVEL
MIDL1:	SET	$
	MOV	C,4(X)
	MOV	B,5(X)
	PUSH	B
	POP	X
	CMP	1(X)
	JRNZ	MIDL1
	XRA	A
	ENDMAC
DSUB:	MACRO	Q,SIZE
	IF	0!SIZE&8000H
	CALL	.FSUB
	IF	F
	JC	.FLTERR
	ENDIF
	ELSE
	XRA	A
	DSBC	Q D
	ENDIF
	ENDMAC
DADD	MACRO	Q,SIZE
	IF	0!SIZE&8000H
	CALL	.FADD
	IF	F
	JC	.FLTERR
	ENDIF
	ELSE
	IF	'Q'-'C'
	DAD	Q D
	ELSE
	IF	M&A
	XRA	A
	DADC	H
	JV	.MLTERR
	ELSE
	DAD	H
	ENDIF
	ENDIF
	ENDIF
	ENDMAC
ENTR:	MACRO	Q,LVL,VSIZ
	IF	LVL-1
	MVI	B,LVL
	LXI	D,1-VSIZ
	IF	S
	CALL	.ENTRSC
	ELSE
	CALL	.ENTER
	ENDIF
	ELSE
	Error	Main programs may not be externals
	JC	.STKERR
	ENDIF
	ENDMAC
EXIT:	MACRO	Q,SSIZ
	LXI	H,SSIZ+8
	JMP	.EXITF
	ENDMAC
EQUL:	MACRO	Q,SIZE1,SIZE2
	IF	'Q'-'S'
	IF	SIZE1
	IF	SIZE1&8000H
	CALL	.FPEQ
	ELSE
	LXI	B,SIZE1
	CALL	.SEQUL
	ENDIF
	ENDIF
	ELSE
	LXI	B,SIZE1*255-257+SIZE1+SIZE2
	CALL	.STREQL
	ENDIF
	ENDMAC
NEQL:	MACRO	Q,SIZE1,SIZE2
	IF	'Q'-'S'
	IF	SIZE1
	IF	SIZE1&8000H
	CALL	.FPNEQ
	ELSE
	LXI	B,SIZE1
	CALL	.SNE
	ENDIF
	ENDIF
	ELSE
	LXI	B,SIZE1*255-257+SIZE1+SIZE2
	CALL	.STRNQL
	ENDIF
	ENDMAC
LE:	MACRO	Q,SIZE1,SIZE2
	IF	'Q'-'S'
	IF	SIZE1
	IF	SIZE1&8000H
	CALL	.FPLTE
	ELSE
	LXI	B,SIZE1
	CALL	.SLE
	ENDIF
	ELSE
	CALL	.ILE
	ENDIF
	ELSE
	LXI	B,SIZE1*255-257+SIZE1+SIZE2
	CALL	.STRLEQ
	ENDIF
	ENDMAC
LESS:	MACRO	Q,SIZE1,SIZE2
	IF	'Q'-'S'
	IF	SIZE1
	IF	SIZE1&8000H
	CALL	.FPLT
	ELSE
	LXI	B,SIZE1
	CALL	.SLT
	ENDIF
	ELSE
	CALL	.ILT
	ENDIF
	ELSE
	LXI	B,SIZE1*255-257+SIZE1+SIZE2
	CALL	.STRLSS
	ENDIF
	ENDMAC
GE:	MACRO	Q,SIZE1,SIZE2
	IF	'Q'-'S'
	IF	SIZE1
	IF	SIZE1&8000H
	CALL	.FPGTE
	ELSE
	LXI	B,SIZE1
	CALL	.SGE
	ENDIF
	ELSE
	CALL	.IGE
	ENDIF
	ELSE
	LXI	B,SIZE1*255-257+SIZE1+SIZE2
	CALL	.STRGEQ
	ENDIF
	ENDMAC
GRET:	MACRO	Q,SIZE1,SIZE2
	IF	'Q'-'S'
	IF	SIZE1
	IF	SIZE1&8000H
	CALL	.FPGT
	ELSE
	LXI	B,SIZE1
	CALL	.SGT
	ENDIF
	ELSE
	CALL	.IGT
	ENDIF
	ELSE
	LXI	B,SIZE1*255-257+SIZE1+SIZE2
	CALL	.STRGRT
	ENDIF
	ENDMAC
FDVD:	MACRO	Q,SIZE
	CALL	.FDIVD
	IF	F
	JC	.DIVERR
	ENDIF
	ENDMAC
MULT:	MACRO	Q,SIZE
	IF	0!SIZE&8000H
	CALL	.FMULT
	IF	F
	JC	.MLTERR
	ENDIF
	ELSE
	IF	M
	CALL	.IMULT
	ELSE
	CALL	.QMULT
	ENDIF
	ENDIF
	ENDMAC
DIVD:	MACRO
	IF	M
	CALL	.IDIVD
	ELSE
	CALL	.NCDVD
	ENDIF
	ENDMAC
MMOD:	MACRO
	IF	M
	CALL	.IMOD
	ELSE
	CALL	.NCMOD
	ENDIF
	ENDMAC
NEGT:	MACRO	REG
	IF	'REG'-'H'
	IF	'REG'-'D'
	CALL	.FPNEG
	ELSE
	MOV	A,E
	CMA
	MOV	E,A
	MOV	A,REG
	CMA
	MOV	REG,A
	INX	REG
	ENDIF
	ELSE
	MOV	A,L
	CMA
	MOV	L,A
	MOV	A,REG
	CMA
	MOV	REG,A
	INX	REG
	ENDIF
	XRA	A
	ENDMAC
CTRL:	MACRO	Q,X
	STMT	M,X
	IF	C
	CALL	.CSTS
	JRZ	$+16
	CALL	.CI
	CPI	'C'&3FH
	JZ	.ERROR
	MVI	C,7
	CALL	.CO
	XRA	A
	ENDIF
	ENDMAC
RCHK:	MACRO	REG,LBND,HBND
	LXI	B,LBND
	IF	'REG'-'H'
	IF	'REG'-'S'
	PUSH	H
	LXI	H,HBND
	CALL	.CHKDE
	POP	H
	ELSE
	MVI	A,LBND
	CMP	M
	JC	.STRERR
	XRA	A
	ENDIF
	ELSE
	PUSH	D
	LXI	D,HBND
	CALL	.CHKHL
	POP	D
	ENDIF
	ENDMAC
STMT:	MACRO	Q,NUMBER
	IF	T+E
VALID	SET	0FFFFH
	EXX
	LXI	B,NUMBER
	IF	T
	IF	'M'-'Q'
	CALL	.PSTAT
	ENDIF
	ENDIF
	EXX
	ELSE
	IF	VALID
	EXX
	MOV	B,A
	MOV	C,A
	EXX
VALID	SET	00000H
	ENDIF
	ENDIF
	ENDMAC
GLBP	MACRO	Q,OFFSET,SIZE
	PUSH	Y
	POP	B
	DAD	B
	MOV	B,M
	DCX	H
	MOV	L,M
	MOV	H,B
	LXI	B,OFFSET
	DAD	B
	IF	SIZE-1
	MOV	B,M
	DCX	H
	MOV	L,M
	MOV	H,B
	ELSE
	MOV	L,M
	MOV	H,A
	ENDIF
	ENDMAC
CSET:	MACRO	Q,OFF
	IF	OFF
	IF 	OFF-1
	CALL	.RCSET
	ELSE
	CALL	.CONSET
	ENDIF
	ELSE
	MVI	B,16
	LXI	H,0
CSETCL:	SET	$
	PUSH	H
	DJNZ	CSETCL
	ENDIF
	ENDMAC
UNIN:	MACRO	Q,OFFSET,OFF1
	CALL	.UNION
	ENDMAC
MEMB:	MACRO	Q,OFFSET,OFF2
	CALL	.INN
	ENDMAC
INCL:	MACRO	Q,OFFSET,OFF1
	CALL	.LTEQ
	ENDMAC
SBST:	MACRO	Q,OFFSET,OFF1
	CALL	.GTEQ
	ENDMAC
INTR:	MACRO	Q,OFFSET,OFF1
	CALL	.INSECT
	ENDMAC
DIFF:	MACRO	Q,OFFSET,OFF1
	CALL	.ORGAN
	ENDMAC
MTCH:	MACRO	Q,OFFSET,OFF1
	CALL	.COMP
	ENDMAC
NOMT:	MACRO	Q,OFFSET,OFF1
	CALL	.FUSS
	ENDMAC
xcfp:	macro
	pop	d
	pop	h
	pop	b
	xthl
	push	d
	push	h
	push	b
	endmac
cvtf:	macro	where,value
	if	'A'-'where'
	if	'B'-'where'
	if	'C'-'where'
	if	'D'-'where'
	if	'H'-'where'
	if	value-4
	mov	a,l
	pop	b
	pop	d
	pop	h
	mov	h,a
	push	h
	push	d
	push	b
	xra	a
	call	.fout
	dcx	s
	lxi	h,14
	dad	s
	push	h
	call	.fxdcvt
	else
	call	.fout
	dcx	s
	lxi	h,0
	dad	s
	xchg
	lxi	h,1
	dad	d
	lxi	b,14
	ldir
	dcx	h
	mvi	m,14
	endif
	else
	call	.cvtflt
	endif
	else
	xchg
	call	.cvtflt
	endif
	else
	pop	b
	pop	d
	pop	h
	push	d
	push	b
	call	.cvtflt
	xcfp
	endif
	else
	pop	h
	call	.cvtflt
	endif
	else
	lxi	h,value
	call	.cvtflt
	endif
	endmac
dsb1	macro	reg
	xra	a
	dsbc	reg d
	endmac
cmpi	macro	q,value
	cpi	value
	endmac

svln:	macro
	mov	a,m
	exx
	mov	e,a
	xra	a
	exx
	dcx	h
	endmac

gtln:	macro	reg,size
	exx
	mov	a,e
	exx
	mov	c,a
	xra	a
	mov	b,a
	lxi	h,size
	dsub	b
	dad	s
	mvi	m,cr
	endmac
;
; Pascal routines to become external modules
;    (remember to include the ENTRY statements so that the linker can
;     find your module)
;







                                                                                                                 