; Pascal/Z run-time support interface          
; COPYRIGHT 1978, 1979, 1980, 1981 BY JEFF MOSKOW
;MACROS USED BY THE COMPILER, ERROR STATEMENTS, AND START ROUTINE
;
	NAME MAIN
	ENTRY .FLTERR,.HPERR,.REFERR,.STKERR,.RNGERR,.DIVERR,.MLTERR,L98
	ENTRY .PERROR,.STMTMSG,.CRLF,.CHIN$,.STRERR,.MAXOUT,.MXOUT,.MXUT1
	ENTRY .STRMSG,.START
	EXT .ILDV,.ILDV1,.ILDV2,.ILD1,.ILD11,.ILD12,.ILD2,.ILD21
	EXT .ILD22,.FPNEG
	EXT .ISTR,.ISTR1,.ISTR2,.XADDR,.YADDR,.FSUB,.FADD,.ENTRSC,.ENTER
	EXT .EXITF,.NCDVD,.NCMOD
	EXT .FPEQ,.SEQUL,.FPNEQ,.SNE,.FPLTE,.SLE,.ILE,.FPLT,.SLT,.ILT,.RCSET
	EXT .FPGTE,.SGE,.IGE,.FPGT,.SGT,.IGT,.FMULT,.IMULT,.QMULT,.IDIVD,.IMOD
	EXT .ERROR,.CSTS,.CI,.CO,.CHKDE,.CHKHL,.PSTAT,.CONSET,.UNION,.INN
	EXT .LTEQ,GTEQ,.INSECT,.ORGAN,.COMP,.FUSS,.FOUT,.FXDCVT,.CVTFLT,.TOUT
	EXT .TXTYP,.FDIVD,.STREQL,.STRNQL,.STRLEQ,.STRLSS,.STRGEQ,.STRGRT,.LAST
;
;
; PASCAL INSTRINSIC ROUTINE ENTRY POINTS
;
	EXT	.WRITELN,L109,L110,L111,L112,L115,L116,L117,L118,L120
	EXT	.READLN,L121,L122,L123,L124,L125,L126,L127,L128,L129
	EXT	.WRITE,L130,L131,L132,L133,L134,L135,L136,L0
	EXT	.READ,L137,.ABS,.FPABS,.SQR,.FPSQR,.EOLN,.EOF,.RESET,.REWRITE
	EXT	.FTXTIN,.CHAIN,.NEW,.MARK,.RELEASE,.TRUNC,.ROUND,.ARCTAN,.COS
	EXT	.EXPFCT,.LN,.SQRT,.SIN
;
; PASCAL RUN-TIME SUPPORT LIBRARY	
;
;	2/15/79
;
; INITIALIZE SOME RUN-TIME PARAMETERS TO THEIR CORRECT DEFAULT VALUES
;
R:	SET	0FFFFH		;DEFAULT FOR RANGE  CHECKING IS YES
C:	SET	0FFFFH		;   "     "  CTRL-C     "     "  "
M:	SET	0FFFFH		;   "     "  MATH       "     "  "
S:	SET	0FFFFH		;   "     "  STACK      "     "  "
D:	SET	0FFFFH		;   "     "  DIVIDE     "     "  "
E:	SET	00000H		;   "     "  EXTENDED ERROR MESSAGES IS OFF
F:	SET	0FFFFH		;DEFAULT FOR FLOATING POINT CHECKING IS ON.
T:	SET	00000H		;   "     "  DEFAULT FOR TRACE OPTION IS OFF
VALID:	SET	00000H		;STATEMENT NUMBER ISN'T VALID
;
;
; PASCAL DEFAULTS
;
.MAXOUT	EQU	4		;NUMBER OF ALLOWABLE OUTPUT FILES
.MXOUT	EQU	.MAXOUT*256	;MAXOUT FOR TRANSPORT TO OTHER MODS
.MXUT1	EQU	.MXOUT*2		;FOR FILEXT MOD ONLY
CR	EQU	13		;CARRIAGE RETURN
LF	EQU	10		;LINE FEED
EOFMRK	EQU	1AH		; Enf of file marker.
BUFLEN	EQU	80		;SIZE OF PASCAL'S CONSOLE BUFFER.
TOPFRM	EQU	MAXOUT+MAXOUT+BUFLEN+3+1	;SPACE FOR STACK FRAME #1
MARGIN	EQU	50		;STACK OVERFLOW MARGIN

COMPILER EQU	0H		;TRUE IF ASSEMBLING THE COMPILER.

MAXDRV	EQU	16		;MAXIMUM # OF DRIVES (USED BY FILNAM).
CPM	EQU	5		;CP/M ENTRY ADDRESS.
;
;
.START:	MVI	C,25		; CP/M CODE TO GET CURRENT DRIVE NUMBER.
	CALL	CPM
	LHLD	6		;GET POINTER TO TOP OF MEMORY.
	DCX	H
	MOV	M,A		;STORE DEFAULT DRIVE NUMBER.

	LXI	B,0		;CLEAR STATEMENT NUMBER
	LXI	H,.LAST		;Start of heap.
	EXX
	LHLD	6		; 1 PAST LAST BYTE IN RAM.
	LXI	D,0-TOPFRM-1	; AMOUNT OF SPACE TO RESERVE + 1.
	DAD	D
	PUSH	H
	PUSH	H
	POP	X
	POP	Y
	SPHL			;MAKE SP DO THE SAME
	MVI	B,.MAXOUT*2+1
	XRA	A		;CLEAR FILE AREA ABOVE THE STACK
CLRSTK:	MOV	M,A		
	INX	H	
	DJNZ	CLRSTK	
	INX	H
	MOV	M,A		; PUT_CHAR_POINTER := 0 (BUFFER EMPTY).
;STICK STRING RESIDING AT COMMAND TAIL BUFFER (80H) IN TEXT BUFFER FOR
;CONSUMPTION BY PASCAL PROGRAM (THE COMPILER USES THIS).
	LXI	H,80H		; ADDRESS OF TEXT BUFFER WITH REST OF COM LINE.
	MOV	A,M		; IF ZERO CHARS. OR ONE CHAR.(MUST BE A SPACE)
	CPI	2		; IN COMMAND TAIL, THEN END OF BUFFER LINE
	JRC	NOCOM
	MOV	B,M		; B := NUMBER OF CHARACTERS.
	DCR	B
	INX	H		; POINT TO FIRST CHARACTER.
INITLP	INX	H
	MOV	C,M
	CALL	.TOUT		; STUFF CHARACTER INTO OUR BUFFER.
	DJNZ	INITLP
NOCOM	MVI	C,CR
	CALL	.TOUT		; Mark the end of buffer line.
; L99 is the label on the first line of code of the program translated
; by the Pascal/z compiler.
	JMP	L99
;
FINI:	MACRO			;;STARTING ADDR. OF PROGRAM
	JMP	L0
	END	.START
	ENDMAC			
;
EXTD:	MACRO	INTN,EXTN	;;TO LINK EXT.RTS. TO MAIN PROG.
	EXT	EXTN
INTN:	equ	EXTN
	ENDMAC
;
SPSH:	MACRO	Q,SIZE		;;PUSH A STRING
	IF 	SIZE		;;ZERO SIZE,FALL THROUGH
	IF	SIZE&8000H	;;CHECK FOR NEG. SIZE
	LXI	H,SIZE		;;NEG. SIZE.PUSH 'SIZE' BYTES OF JUNK
	DAD	S
	SPHL
	ELSE
	MVI	A,SIZE		;;POS. NON-ZERO SIZE
	CMP	M		;;CHECK RANGE
	JC	.STRERR		;;STRING OVERFLOW
	MOV	B,A		;;B IS COUNTER
	INR	B		;;ALSO PUSHING LENGTH
PSHLP:	SET	$
	MOV	D,M		;;D <- CHAR
	PUSH	D
	INX	S		;;ONLY ONE BYTE
	DCX	H		;;NEXT CHAR
	DJNZ	PSHLP
	XRA	A
	ENDIF
	ENDIF	
	ENDMAC
;
MLOAD:	MACRO	WHERE,VALUE	;;DO A MINIMUM LENGTH LOAD FOR ILOD1, ILOD2....
	IF	VALUE		;;CHECK FOR A NON-ZERO VALUE
	IF	VALUE&0FF00H	;;CHECK FOR A VALUE > 255
	LXI	B,VALUE		;;LOAD THE VALUE
	CALL	WHERE!2		;;GO TO THE ROUTINE
	ELSE
	MVI	C,VALUE		;;LOAD ONLY THE LOW BYTE
	CALL	WHERE!1		;;GO TO THE ROUTINE
	ENDIF
	ELSE
	CALL	WHERE		;;GO TO THE ROUTINE AND LOAD A ZERO
	ENDIF
	ENDMAC

;
;
ILOD:	MACRO	Q,SIZE,OFST	;;INDIRECT LOAD (FOR CALL BY REF VARS
	IF	SIZE&8000H	;;NEGATIVE SIZE
	MLOAD	.ILDV,OFST	;;LOAD AND GO
	ELSE			;;VARIABLE SIZE IS KNOWN
	IF	SIZE-1		;;IF VARIABLE SIZE IS NOT 1
	MLOAD	.ILD2,OFST	;;LOAD AND GO
	ELSE			;;DO VARS WITH A SIZE OF 1
	MLOAD	.ILD1,OFST	;;LOAD AND GO
	ENDIF
	ENDIF
	ENDMAC			;;END OF ILOD
;
;
;
ISTR:	MACRO	Q,SIZE,OFST	;;INDIRECT STORE A VARIABLE LENGTH INTEGER
	MLOAD	.ISTR,OFST	;;LOAD AND GO
	IF	R		;;RANGE CHECKING
	JC	.REFERR		;;CALL BY REF ERROR
	ENDIF
	ENDMAC
;
;
; LPOP -- POP A VALUE FROM THE MIDDLE OF THE STACK
; USED ONLY FOR SET ASSIGNMENTS
;
LPOP:	MACRO	REG,DISTANCE	;;LONG POP
	IF	DISTANCE	;;LONG POP
	PUSH	H		;;SAVE HL
	LXI	H,DISTANCE+2	;;POINT TO ITEM TO POP
	DAD	S
	MOV	E,M		;;GET LOW BYTE
	INX	H
	MOV	D,M		;;GET HIGH BYTE
	PUSH	D		;;SAVE THIS VALUE
	MOV	D,H		;;COPY POINTER
	MOV	E,L
	DCX	H		;;POINT TO INTERMEDIATE BLOCK
	DCX	H
	LXI	B,DISTANCE	;;LENGTH OF INTERMEDIATE BLOCK
	LDDR			;;MOVE BLOCK UP 2 BYTES
	POP	D		;;GET NEW DE VALUE
	POP	H		;;RESTORE HL
	POP	B		;;FIX STACK POINTER
	ELSE			;;SHORT POP
	POP	D
	ENDIF
	ENDMAC
;
;LONG PUSH
;
LPUSH:	MACRO	REG,SIZE	;;PUSH A REG. 'SIZE' BYTES ABOVE SP
	IF	SIZE-2 
	PUSH	REG		;;SAVE REG
	LXI	H,0
	DAD	S		;;HL <- SP
	XCHG			;;DE <- SP
	LXI	H,-2
	DAD	S		;;TWO BYTES BELOW SP	
	SPHL			;;SP LOWERED BY TWO BYTES
	XCHG			;;DE <- SP
	LXI	B,SIZE+2
	LDIR			;;LOWER 'SIZE' + 2 BYTES OF STACK BY 2 BYTES
	POP	D		;;POP DATA TO LONG PUSH
	LXI	H,SIZE
	DAD	S		;;LOCATION FOR LOW BYTE
	MOV	M,E
	INX	H		;;LOCATION FOR HIGH BYTE
	MOV	M,D
	ELSE			;;LONG PUSH 2 BYTES UP ON STACK
	IF	'REG'-'H'
	XCHG			;;IF REG IS HL, EXCHANGE
	ENDIF
	XTHL			;;SWITCH HL AND TOP OF STACK
	PUSH	H		;;AND PUSH
	ENDIF
	ENDMAC
;
;
ADDR:	MACRO	Q		;;CALCULATE ADDRESS USING SPECIFIED REG
TEMP	SET	'Q'-'IY'
	IF	'Q'-'Y'*TEMP	;;DEFAULT IS X-REG
	CALL	.XADDR		;;CALL ROUTINE TO DO IT
	ELSE
	CALL	.YADDR		;;OTHERWISE USE Y-REG
	ENDIF
	ENDMAC
;
;
MIDL:	MACRO	REG,LEVEL	;;SET IX TO POINT TO A DIFFERENT LEVEL
	PUSH	X		;;SAVE PRESENT IX
	MVI	A,LEVEL
MIDL1:	SET	$		;;LOOP INDICATOR
	MOV	C,4(X)		;;GET OLD IX
	MOV	B,5(X)
	PUSH	B		;;MOVE POINTER TO IX
	POP	X
	CMP	1(X)		;;CHECK FOR RIGHT LEVEL
	JRNZ	MIDL1		;;NO...TRY AGAIN
	XRA	A		;;CLEAR ACCUMULATOR
	ENDMAC			;;YES, KEEP ON GOING
;
;
DSUB:	MACRO	Q,SIZE
	IF	0!SIZE&8000H	;;CHECK FOR FLOATING POINT SUBTRACTION
	CALL	.FSUB
	IF	F		;;CHECK FOR ERROR IF REQUIRED
	JC	.FLTERR
	ENDIF
	ELSE			;;SUBTRACT Q OR DE FROM HL
	XRA	A		;;CLEAR CARRY
	DSBC	Q D		;;SUBTRACT IT
	ENDIF
	ENDMAC			;;DONE
;
;
DADD	MACRO	Q,SIZE
	IF	0!SIZE&8000H	;;CHECK FOR FLOATING POINT ADD
	CALL	.FADD
	IF	F		;;CHECK FOR ERROR IF REQUIRED
	JC	.FLTERR
	ENDIF
	ELSE
	IF	'Q'-'C'+COMPILER;;DADD C IS DAD H WITH CHECKING
	DAD	Q D		;;ADD Q OR DE TO HL
	ELSE
	IF	M		;;CHECK FOR ERROR CHECKING
	XRA	A		;;CLEAR CARRY
	DADC	H		;;ADD H TO ITSELF
	JV	.MLTERR		;;MULTIPLY OVERFLOW
	ELSE
	DAD	H		;;H := H * 2;
	ENDIF
	ENDIF
	ENDIF
	ENDMAC
;
;
;
ENTR:	MACRO	Q,LVL,VSIZ	;;ENTER A PROC/FCT ON LVL WITH VSIZ VARS
	IF	LVL-1		;;CHECK FOR INNER LEVELS
	MVI	B,LVL		;;SAVE LEVEL NUMBER
	LXI	D,1-VSIZ	;;SAVE VSIZ BYTES OF STACK
	IF	S		;;DO STACK CHECKING
	CALL	.ENTRSC		;;ENTER WITH STACK CHEKING
	ELSE
	CALL	.ENTER		;;A SUBROUTNE WILL FINISH
	ENDIF
	ELSE			;;LEVEL 1
;put .CHIN$ here when chaining between programs with no sharing of
;global variables
	LXI	H,1-VSIZ	;;SET UP STACK POINTER
	DAD	S
	SPHL
;; LABEL TO JUMP TO FOR A CHAINED PROGRAM
.CHIN$:
	EXX
	LXI	H,.LAST		;;INDICATE TOP OF HEAP
	EXX
	LXI	H,-MARGIN	;;CHECK FOR A STACK OVERFLOW
	DAD	S
	LXI	D,.LAST		;;DO STACK CHECKING FOR LEVEL 1
	DSUB	D		;;SUBTRACT DE FROM HL
	JC	.STKERR		;;OVERFLOW!!
	ENDIF
	ENDMAC			;;ALL ENTERED
;
;
EXIT:	MACRO	Q,SSIZ		;;EXIT FROM A PROC/FCT
	LXI	H,SSIZ+8	;;GET NUMBER OF STACK BYTES
	JMP	.EXITF		;;FINISH UP IN A SUBROUTINE
	ENDMAC
;
;
; THIS ROUTINE IS USED TO DO A UNIT TIME CASE SELECTION WITH THE
; AID OF A JUMP TABLE CREATED BY THE COMPILER FOR THIS CASE STATMENT
;
L98:	DAD	D		;CONVERT INDEX FROM BYTE COUNTER TO WORD COUNTER
	DAD	D		;ADD IN ADDRESS OF THE ZEROETH TABLE ELEMENT
	MOV	E,M		;GET LOW BYTE OF ADDRESS
	INX	H
	MOV	D,M		;GET HIGH BYTE OF ADDRESS
	XCHG			;STATEMENT ADDRESS -> HL
	PCHL			;EXECUTE THE STATEMENT
;
EQUL:	MACRO	Q,SIZE1,SIZE2	;;EQUALITY TEST
	IF 	'Q'-'S'		;;TEST FOR STRING
	IF	SIZE1		;;TEST FOR STRUCTURED RELOP
	IF	SIZE1&8000H	;;CHECK FOR FP OPERATION
	CALL	.FPEQ		;;YES, DO FP OP
	ELSE
	LXI	B,SIZE1
	CALL	.SEQUL		;;STRUCTURED RELOP
	ENDIF
	ENDIF
	ELSE
	LXI	B,SIZE1*255-257+SIZE1+SIZE2	;;PASS SIZE1-1 AND SIZE2-1
				;;IN BC PAIR.  SIZES READJUSTED IN STRLOP
	CALL	.STREQL		;;STRING RELOP
	ENDIF
	ENDMAC
;
NEQL:	MACRO	Q,SIZE1,SIZE2	;;NON-EQUALITY TEST
	IF	'Q'-'S'		;;TEST FOR STRING RELOP
	IF	SIZE1		;;TEST FOR STRUCTURED RELOP
	IF	SIZE1&8000H	;;CHECK FOR FP OPERATION
	CALL	.FPNEQ		;;YES, DO FP OP
	ELSE
	LXI	B,SIZE1
	CALL	.SNE		;;STRUCTURED RELOP
	ENDIF
	ENDIF
	ELSE
	LXI	B,SIZE1*255-257+SIZE1+SIZE2	;;PASS SIZE1-1 AND SIZE2-1
				;;IN BC PAIR.  SIZES READJUSTED IN STRLOP
	CALL	.STRNQL		;;STRING RELOP
	ENDIF
	ENDMAC
;
LE:	MACRO	Q,SIZE1,SIZE2	;;LESS THAN OR EQUAL TEST
	IF	'Q'-'S'		;;TEST FOR STRING RELOP
	IF	SIZE1		;;TEST FOR STRUCTURED RELOP
	IF	SIZE1&8000H	;;CHECK FOR FP OPERATION
	CALL	.FPLTE		;;YES,DO FP OP
	ELSE
	LXI	B,SIZE1
	CALL	.SLE		;;STRUCTURED RELOP
	ENDIF
	ELSE
	CALL	.ILE		;;INTEGER TEST
	ENDIF
	ELSE
	LXI	B,SIZE1*255-257+SIZE1+SIZE2	;;PASS SIZE1-1 AND SIZE2-1
				;;IN BC PAIR.  SIZES READJUSTED IN STRLOP
	CALL	.STRLEQ		;;STRING RELOP
	ENDIF
	ENDMAC
;
LESS:	MACRO	Q,SIZE1,SIZE2	;;LESS THAN TEST
	IF	'Q'-'S'		;;TEST FOR STRING RELOP
	IF	SIZE1		;;TEST FOR STRUCTURED RELOP
	IF	SIZE1&8000H	;;CHECK FOR FP OPERATION
	CALL	.FPLT		;;YES, DO FP OP
	ELSE
	LXI	B,SIZE1
	CALL	.SLT		;;STRUCTURED RELOP
	ENDIF
	ELSE
	CALL	.ILT		;;INTEGER TEST
	ENDIF
	ELSE
	LXI	B,SIZE1*255-257+SIZE1+SIZE2	;;PASS SIZE1-1 AND SIZE2-1
				;;IN BC PAIR.  SIZES READJUSTED IN STRLOP
	CALL	.STRLSS		;;STRING RELOP
	ENDIF
	ENDMAC
;
GE:	MACRO	Q,SIZE1,SIZE2	;;GREATER THAN OR EQUAL TO TEST
	IF	'Q'-'S'		;;TEST FOR STRING RELOP
	IF	SIZE1		;;TEST FOR STRUCTURED RELOP
	IF	SIZE1&8000H	;;CHECK FOR FP OPERATION
	CALL	.FPGTE		;;YES, DO FP OPERATION
	ELSE
	LXI	B,SIZE1
	CALL	.SGE		;;STRUCTURED RELOP
	ENDIF
	ELSE
	CALL	.IGE		;;INTEGER TEST
	ENDIF
	ELSE
	LXI	B,SIZE1*255-257+SIZE1+SIZE2	;;PASS SIZE1-1 AND SIZE2-1
				;;IN BC PAIR.  SIZES READJUSTED IN STRLOP
	CALL	.STRGEQ		;;STRING RELOP
	ENDIF
	ENDMAC
;
GRET:	MACRO	Q,SIZE1,SIZE2	;;GREATER THAN TEST
	IF	'Q'-'S'		;;TEST FOR STRING RELOP
	IF	SIZE1		;;TEST FOR STRUCTURED RELOP
	IF	SIZE1&8000H	;;CHECK FOR FP OPERATION
	CALL	.FPGT		;;YES, DO FP OP
	ELSE
	LXI	B,SIZE1
	CALL	.SGT		;;STRUCTURED RELOP
	ENDIF
	ELSE
	CALL	.IGT		;;INTEGER TEST
	ENDIF
	ELSE
	LXI	B,SIZE1*255-257+SIZE1+SIZE2	;;PASS SIZE1-1 AND SIZE2-1
				;;IN BC PAIR.  SIZES READJUSTED IN STRLOP
	CALL	.STRGRT		;;STRING RELOP
	ENDIF
	ENDMAC

;
FDVD:	MACRO	Q,SIZE		;;FLOATING POINT DIVISION
	CALL	.FDIVD
	IF	F		;;CHECK FOR ERROR IF REQUIRED
	JC	.DIVERR
	ENDIF
	ENDMAC
;
;
MULT:	MACRO	Q,SIZE		;;CALL MULTIPLY ROUTINE
	IF	0!SIZE&8000H	;;CHECK FOR FLOATING POINT OPERATION
	CALL	.FMULT
	IF	F		;;CHECK FOR ERROR IF REQUIRED
	JC	.MLTERR
	ENDIF
	ELSE
	IF	M		;;CHECK FOR OVERFLOW
	CALL	.IMULT
	ELSE			;;USE FAST ROUTINE
	CALL	.QMULT
	ENDIF
	ENDIF
	ENDMAC
;
;
DIVD:	MACRO			;;CALL DIVIDE ROUTINE
	IF	M
	CALL	.IDIVD		;;CALL ROUTINE WITH CHECKING
	ELSE
	CALL	.NCDVD		;;CALL ROUTINE W/O CHECKING
	ENDIF
	ENDMAC

;
;
MMOD:	MACRO			;;CALL MOD ROUTINE
	IF	M
	CALL	.IMOD		;;CALL ROUTINE WITH CHECKING
	ELSE
	CALL	.NCMOD		;;CALL ROUTINE W/O CHECKING
	ENDIF
	ENDMAC
;
;
NEGT:	MACRO	REG		;;NEGATE SPECIFIED REGISTER PAIR
	IF	'REG'-'H'	;;DO DE PAIR OR FLOAT
	IF	'REG'-'D'	;;DO FLOAT NUMBER
	CALL	.FPNEG
	ELSE			;;DO DE PAIR
	MOV	A,E
	CMA			;;COMPLEMENT LOW BYTE
	MOV	E,A
	MOV	A,REG
	CMA			;;COMPLEMENT HIGH BYTE
	MOV	REG,A
	INX	REG		;;AND INCREMENT
	ENDIF
	ELSE
	MOV	A,L
	CMA			;;COMPLEMENT LOW BYTE
	MOV	L,A
	MOV	A,REG
	CMA			;;COMPLEMENT HIGH BYTE
	MOV	REG,A
	INX	REG		;;AND INCREMENT
	ENDIF
	XRA	A		;;CLEAR ACCUMULATOR
	ENDMAC
;
; RUN-TIME CONTROL MACROS
;
CTRL:	MACRO	Q,X		;;CHECK FOR A CTRL-C
	STMT	M,X
	IF	C		;;IF CTRL-C CHECKING IS ENABLED
	CALL	.CSTS		;;CHECK FOR A CHARACTER TYPED
	JRZ	$+16		;;NO CHARACTER....CONTINUE
	CALL	.CI		;;GET THE CHARACTER
	CPI	'C'&3FH		;;IS IT A CTRL-C
	JZ	.ERROR		;;YES....ABORT!!!
	MVI	C,7		;;RING BELL
	CALL	.CO
	XRA	A		;;CLEAR THE ACCUMULATOR BEFORE
	ENDIF			;;RETURNING
	ENDMAC
;
;
RCHK:	MACRO	REG,LBND,HBND	;;RANGE CHECK MACRO
	LXI	B,LBND		;;SAVE LOWER BOUND
	IF	'REG'-'H'	;;DO DE REGISTER PAIR OR A STRING CHECK
	IF	'REG'-'S'	;;DO DE PAIR
	PUSH	H		;;SAVE POSSIBLE ADDRESS
	LXI	H,HBND		;;SAVE UPPER BOUND
	CALL	.CHKDE		;;CHECK IT
	POP	H		;;RESTORE POSSIBLE ADDRESS
	ELSE			;;DO STRING CHECK
	MVI	A,LBND		;;MAXIMUM ACCEPTABLE STRING LENGTH
	CMP	M
	JC	.STRERR		;;STRING TOO BIG!
	XRA	A		;;CLEAR ACC
	ENDIF
	ELSE			;;DO HL PAIR
	PUSH	D		;;SAVE DE REGISTER PAIR
	LXI	D,HBND		;;SAVE UPPER BOUND
	CALL	.CHKHL		;;CHECK THE VALUE
	POP	D		;;RESTORE DE
	ENDIF
	ENDMAC
;
;
STMT:	MACRO	Q,NUMBER	;;MACRO FOR TRACES AND....
	IF	T+E		;;....EXTENDED ERROR MESSAGES
VALID	SET	0FFFFH		;;STATEMENT NUMBER IS VALID
	EXX			;;SWITCH REGISTER SETS TO SINCE
	LXI	B,NUMBER	;;STATEMENT NUMBER IS STORED IN OTHER BC
	IF	T		;;PRINT NUMBER IF TRACE
	IF	'M'-'Q'
	CALL	.PSTAT		;;IS ON
	ENDIF
	ENDIF
	EXX			;;RESTORE PROGRAM REGISTERS
	ELSE			;;NO OPTIONS ENABLED
	IF	VALID		;;IF OPTION WAS JUST TURNED OFF
	EXX			;;THEN SET ALTERNATE BC TO ZERO
	MOV	B,A		;;CLEAR BC
	MOV	C,A
	EXX
VALID	SET	00000H		;;SET INVALID FLAG
	ENDIF
	ENDIF
	ENDMAC			;;END OF MACRO
GLBP	MACRO	Q,OFFSET,SIZE	;GLOBAL PTRS. TO ONE OR TWO BYTE VARS.
	PUSH	Y
	POP	B		;GLOBAL VAR. POINTER
	DAD	B		;POINTER ADDRESS
	MOV	B,M
	DCX	H
	MOV	L,M
	MOV	H,B		;VAR ADDR INTO HL
	LXI	B,OFFSET
	DAD	B
	IF 	SIZE-1		;ONE OR TWO BYTES?
	MOV	B,M		;TWO
	DCX	H
	MOV	L,M
	MOV	H,B
	ELSE
	MOV	L,M		;ONE BYTE
	MOV	H,A
	ENDIF
	ENDMAC

;
; ERROR MESSAGES
;
	IF	NOT COMPILER	;The compiler doesn't need these
.STRERR	LXI	H,.STRMSG	;STRING ERROR
	JR	.PERROR
.REFERR	LXI	H,.REFMSG	;BY-REF PRECISION ERROR
	JR	.PERROR
.RNGERR	LXI	H,.RNGMSG	;POINT TO THE OUT OF RANGE MESSAGE
	JR	.PERROR		;PRINT THE ERROR MESSAGE
	ENDIF
.HPERR	LXI	H,.STKMSG	;HEAP OVERFLOW
	JR	.PERROR
.FLTERR	LXI	H,.FLTMSG	;FLOATING POINT ERROR
	JR	.PERROR
.STKERR	LXI	H,.STKMSG	;POINT TO STACK ERROR MESSAGE
	JR	.PERROR
.DIVERR	LXI	H,.OUMSG		;DIVIDE ERROR
	JR	.PERROR
.MLTERR	LXI	H,.MLTMSG	;MULTIPLY ERROR
.PERROR:	CALL	.TXTYP		;PRINT IT
	JMP	.ERROR		;AND ABORT
;
	IF	NOT COMPILER		;The compiler shouldn't need these
.STRMSG	DB	'String too lon','g'+80H
.REFMSG	DB	'Call by reference precision erro','r'+80H
.RNGMSG	DB	'Index or value out of rang','e'+80H
.STMTMSG	DB	' -- statement',' '+80H
	ENDIF
.OUMSG	DB	'Attempted divide by zer','o'+80H
.MLTMSG	IF	COMPILER
	DB	'Too many error','s'+80H
	ELSE	
	DB	'Multiply overflo','w'+80H
	ENDIF
.STKMSG	IF	COMPILER
	DB	'Program too comple','x'+80H
	ELSE
	DB	'Stack overflo','w'+80H
	ENDIF
.FLTMSG	DB	'Floating point erro','r'+80H
.CRLF	DB	CR,LF+80H
;
; MACRO ROUTINES TO PROCESS SETS
;

; CSET IS A MACRO USED TO CONSTRUCT A SET ON THE STACK AT RUNTIME.
;
;  IF THE PARAMETER OFF IS ZERO, THEN 32 BYTES IS ALLOCATED TO THE STACK
;  	AND INITIALIZED TO ZERO, FOR THE SET.
;
;  IF THE PARAMETER OFF IS ONE, THEN SPACE HAS ALREADY BEEN ALLOCATED ON
;	THE STACK AND THE SUBROUTINE .CONSET IS CALLED TO SET THE RELEVANT
;	BIT FOR AN ELEMENT IN THE SET.
;
;  IF THE PARAMETER OFF IS TWO, THEN SPACE HAS ALREADY BEEN ALLOCATED ON
;	THE STACK AND THE SUBROUTINE .RCSET IS CALLED TO SET THE RELEVANT
;	BITS FOR A RANGE ( FOR EXAMPLE ['A'..'Z'] ) OF ELEMENTS IN THE SET.

CSET:	MACRO	Q,OFF
	IF	OFF
	IF 	OFF-1
	CALL	.RCSET	; ADDING A RANGE OF ELEMENTS TO A SET 
	ELSE
	CALL	.CONSET	; ADDING ONE ELEMENT TO A SET
	ENDIF
	ELSE
	MVI	B,16	;ALLOCATE AND ZERO 32 BYTES ON STACK
	LXI	H,0
CSETCL:	SET	$
	PUSH	H
	DJNZ	CSETCL
	ENDIF
	ENDMAC
;
;
UNIN:	MACRO	Q,OFFSET,OFF1
	CALL	.UNION
	ENDMAC
;
;
MEMB:	MACRO	Q,OFFSET,OFF2
	CALL	.INN
	ENDMAC
;
;
INCL:	MACRO	Q,OFFSET,OFF1
	CALL	.LTEQ
	ENDMAC
;
;
SBST:	MACRO	Q,OFFSET,OFF1
	CALL	.GTEQ
	ENDMAC
;
;
INTR:	MACRO	Q,OFFSET,OFF1
	CALL	.INSECT
	ENDMAC
;
;
DIFF:	MACRO	Q,OFFSET,OFF1
	CALL	.ORGAN
	ENDMAC
;
;
MTCH:	MACRO	Q,OFFSET,OFF1
	CALL	.COMP
	ENDMAC
;
;
NOMT:	MACRO	Q,OFFSET,OFF1
	CALL	.FUSS
	ENDMAC

;
;
xcfp:	macro			;;exchange top two floating point numbers
	pop	d		;;get op2 in de, hl
	pop	h
	pop	b		;;get low 16 bits of op1
	xthl			;;exchange high 16 bits of op1 & op2
	push	d		;;save low 16 bits of op2
	push	h		;;save high 16 bits of op1
	push	b		;;save low 16 bits of op1
	endmac
;
; convert an integer to floating point, or fp to ASCII
;
cvtf:	macro	where,value	;;where is the argument and what is it?
;;				;; A -> process immediate argument and push
;;				;; B -> process top of stack
;;				;; C -> process 2nd on stack
;;				;; D -> process # in de
;;				;; H -> process # in hl
;;				;; S -> convert top of stack to a string
	if	'A'-'where'	;;check for NOT A
	if	'B'-'where'	;;check for NOT B
	if	'C'-'where'	;;check for not C
	if	'D'-'where'	;;check for not D
	if	'H'-'where'	;;check for not H
;;				;;process option S
	if	value-4		;;should we attempt to convert to fixed pt
	mov	a,l		;;yes, first save fraction length
	pop	b
	pop	d		;;get fp number
	pop	h		;;get field info
	mov	h,a		;;save fraction length
	push	h		;;restore stack
	push	d
	push	b
	xra	a		;;clear acc
	call	.fout		;;convert to form  ' sx.xxxxxxesxx'
	dcx	s		;;move stack to make room for string
	lxi	h,14		;;point to top of string
	dad	s
	push	h		;;save the parameter
	call	.fxdcvt		;;try to convert to fixed point
	else			;;otherwise simply print the string
	call	.fout		;;process fp -> ascii string
	dcx	s		;;move stack to make room for string
	lxi	h,0
	dad	s		;;bottom of string
	xchg			;;into de
	lxi	h,1
	dad	d		;;old bottom of string
	lxi	b,14		;;14 bytes to move
	ldir			;;shift string down one byte
	dcx	h		;;actual length byte
	mvi	m,14		;;length is 14
	endif
	else			;;process option H
	call	.cvtflt		;;process # in hl
	endif
	else			;;process option D
	xchg			;;put # in hl
	call	.cvtflt		;;process # in hl
	endif
	else			;;process option C
	pop	b		;;get top of stack in bc, de
	pop	d
	pop	h		;;get integer in hl
	push	d		;;save float # on stack
	push	b
	call	.cvtflt		;;convert hl -> float
	xcfp			;;...and exchange op1 & op2
	endif
	else			;;process option B
	pop	h		;;get 2's complement value
	call	.cvtflt		;;call routine to convert # in hl
	endif
	else			;;process option A
	lxi	h,value		;;get 16 bit value
	call	.cvtflt		;;convert to float, and done!!
	endif
	endmac

dsb1	macro	reg
	xra	a
	dsbc	reg d
	endmac
cmpi	macro	q,value
	cpi	value
	endmac
svln:	macro			;;save the length of a string
	mov	a,m		;;in the alt e reg.  used with
	exx			;;gtln to append a carriage 			
	mov	e,a		;;return to a variable length
	xra	a		;;string being used by RESET
	exx			;;and REWRITE
	dcx	h
	endmac

gtln:	macro	reg,size
	exx
	mov	a,e
	exx
	mov	c,a
	xra	a
	mov	b,a
	lxi	h,size
	dsub	b
	dad	s
	mvi	m,cr
	endmac
;
; PASCAL PROGRAM
;

                   